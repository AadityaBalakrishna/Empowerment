package com.safepage.security.service.impl;

import com.empower.epw.aws.api.kms.EpwKmsService;
import com.empower.epw.aws.api.kms.exception.KMSOperationException;
import com.safepage.exception.SafePageException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

class KMSServiceImplTest
{

	private KMSServiceImpl kmsService;
	private EpwKmsService mockEpwKmsService;

	@BeforeEach
	void setUp()
	{
		mockEpwKmsService = mock(EpwKmsService.class);
		kmsService = new KMSServiceImpl(mockEpwKmsService);
	}

	@Test
	void testEncryptUsingAWSKey_Success() throws SafePageException
	{
		String plainText = "hello";
		String keyId = "testKeyId";
		String expectedCipherText = "cipherText123";

		when(mockEpwKmsService.encryptUsingAWSKey(plainText, keyId)).thenReturn(expectedCipherText);

		String result = kmsService.encryptUsingAWSKey(plainText, keyId);

		assertEquals(expectedCipherText, result);
		verify(mockEpwKmsService, times(1)).encryptUsingAWSKey(plainText, keyId);
	}

	@Test
	void testEncryptUsingAWSKey_InvalidPlainText()
	{
		String plainText = "";
		String keyId = "keyId";

		SafePageException ex = assertThrows(SafePageException.class,
				() -> kmsService.encryptUsingAWSKey(plainText, keyId));

		assertEquals("plainText is required!", ex.getMessage());
		verifyNoInteractions(mockEpwKmsService);
	}

	@Test
	void testEncryptUsingAWSKey_InvalidKeyId()
	{
		String plainText = "hello";
		String keyId = "";

		SafePageException ex = assertThrows(SafePageException.class,
				() -> kmsService.encryptUsingAWSKey(plainText, keyId));

		assertEquals("keyId is required!", ex.getMessage());
		verifyNoInteractions(mockEpwKmsService);
	}

	@Test
	void testEncryptUsingAWSKey_ExceptionFromDelegate_ReturnsNull() throws SafePageException
	{
		String plainText = "hello";
		String keyId = "keyId";

		when(mockEpwKmsService.encryptUsingAWSKey(plainText, keyId))
				.thenThrow(new KMSOperationException("boom", new RuntimeException()));

		String result = kmsService.encryptUsingAWSKey(plainText, keyId);

		assertNull(result);
		verify(mockEpwKmsService, times(1)).encryptUsingAWSKey(plainText, keyId);
	}

	@Test
	void testDecryptUsingAWSKey_Success() throws SafePageException
	{
		String cipherText = "cipherText123";
		String expectedPlainText = "hello";

		when(mockEpwKmsService.decryptUsingAWSKey(cipherText)).thenReturn(expectedPlainText);

		String result = kmsService.decryptUsingAWSKey(cipherText);

		assertEquals(expectedPlainText, result);
		verify(mockEpwKmsService, times(1)).decryptUsingAWSKey(cipherText);
	}

	@Test
	void testDecryptUsingAWSKey_InvalidCipherText()
	{
		String cipherText = "";

		SafePageException ex = assertThrows(SafePageException.class,
				() -> kmsService.decryptUsingAWSKey(cipherText));

		assertEquals("cipherText is required!", ex.getMessage());
		verifyNoInteractions(mockEpwKmsService);
	}

	@Test
	void testDecryptUsingAWSKey_ExceptionFromDelegate_ReturnsNull() throws SafePageException
	{
		String cipherText = "cipherText123";

		when(mockEpwKmsService.decryptUsingAWSKey(cipherText))
				.thenThrow(new KMSOperationException("boom", new RuntimeException()));

		String result = kmsService.decryptUsingAWSKey(cipherText);

		assertNull(result);
		verify(mockEpwKmsService, times(1)).decryptUsingAWSKey(cipherText);
	}
}


can you update this so that all the funcitonality is tested and proved that the old behaviour is maintained
