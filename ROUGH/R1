package com.empower.epw.sdk.v1.adapter.sqs;

import com.amazonaws.auth.AWSStaticCredentialsProvider;
import com.amazonaws.auth.BasicAWSCredentials;
import com.amazonaws.client.builder.AwsClientBuilder;
import com.amazonaws.services.sqs.AmazonSQS;
import com.amazonaws.services.sqs.AmazonSQSClientBuilder;
import com.empower.epw.aws.dto.sqs.request.*;
import com.empower.epw.aws.dto.sqs.result.SQSMessage;
import com.empower.epw.aws.dto.sqs.result.SQSMessageBatchResponse;
import org.junit.jupiter.api.Test;
import org.mockito.Spy;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;
import org.testcontainers.containers.localstack.LocalStackContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;
import org.testcontainers.utility.DockerImageName;

import java.util.ArrayList;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;


@SpringBootTest(classes = {
        EpwSQSServiceImpl.class,
        EpwSQSServiceImplIntegrationTest.SQSTestConfig.class
})
@Testcontainers
public class EpwSQSServiceImplIntegrationTest {

    public static final String DELETE_QUEUE_TEST = "delete-queue-test";
    public static final String PURGE_QUEUE_TEST = "purge-queue-test";
    public static final String DELETE_MESSAGE_TEST = "delete-message-test";
    public static final String BATCH_QUEUE_TEST = "batch-queue-test";

    @Container
    static LocalStackContainer localStack = new LocalStackContainer(
            DockerImageName.parse("localstack/localstack:0.11.3"))
            .withServices(LocalStackContainer.Service.SQS)
            .withReuse(true);

    @TestConfiguration
    static class SQSTestConfig {
        @Bean
        public AmazonSQS amazonSQS() {
            return AmazonSQSClientBuilder.standard()
                    .withEndpointConfiguration(new AwsClientBuilder.EndpointConfiguration(
                            localStack.getEndpointOverride(LocalStackContainer.Service.SQS)
                                    .toString(),
                            localStack.getRegion()))
                    .withCredentials(new AWSStaticCredentialsProvider(new BasicAWSCredentials(localStack.getAccessKey(),
                            localStack.getSecretKey())))
                    .build();
        }
    }

    @DynamicPropertySource
    static void overrideProperties(DynamicPropertyRegistry registry) {
        registry.add("cloud.aws.region.static", localStack::getRegion);
        registry.add("cloud.aws.credentials.access-key", localStack::getAccessKey);
        registry.add("cloud.aws.credentials.secret-key", localStack::getSecretKey);

        registry.add("cloud.aws.sqs.endpoint",
                () -> localStack.getEndpointOverride(LocalStackContainer.Service.SQS)
                        .toString());
    }

    @SpringBootApplication(exclude = DataSourceAutoConfiguration.class)
    static class TestApplication {
    }

    @Autowired
    private EpwSQSServiceImpl sqsService;

    @Autowired
    private AmazonSQS amazonSQSClient;

    @Test
    void testCreateAndDeleteQueue() throws Exception {
        // Create queue with name purge-queue-test
        String createdUrl = sqsService.createQueue(DELETE_QUEUE_TEST);

        // Queue url should be created containing the queue name in it
        assertNotNull(createdUrl);
        assertTrue(createdUrl.contains(DELETE_QUEUE_TEST));

        // Delete the queue
        sqsService.deleteQueue(createdUrl);

        // GetQueueUrl should throw exception as queue is deleted
        assertThrows(Exception.class, () -> sqsService.getQueueUrl(DELETE_QUEUE_TEST));
    }

    @Test
    void testReceiveMessageAndPurgeQueue() throws Exception {
        // Create queue with name purge-queue-test
        String createdUrl = sqsService.createQueue(PURGE_QUEUE_TEST);
        assertNotNull(createdUrl);
        
        // Send a message into the queue
        SQSSendMessageRequest sendMessageRequest = SQSSendMessageRequest.builder()
                .queueUrl(createdUrl)
                .messageBody("Test message before purge")
                .delaySeconds(1)
                .build();
        sqsService.sendMessage(sendMessageRequest);

        SQSReceiveMessageRequest receiveMessageRequest = SQSReceiveMessageRequest.builder()
                .queueUrl(createdUrl)
                .visibilityTimeout(1)
                .waitTimeSeconds(1)
                .build();

        // Read message from the queue before purge
        List<SQSMessage> messages = sqsService.receiveMessage(receiveMessageRequest).getMessages();
        assertFalse(messages.isEmpty(), "Queue should not be empty before purge.");

        // Purge the queue
        sqsService.purgeQueue(createdUrl);

        // Read message from the queue after purge
        List<SQSMessage> emptyMessages = sqsService.receiveMessage(receiveMessageRequest).getMessages();
        assertTrue(emptyMessages.isEmpty(), "Queue should be empty after purge.");
    }

    @Test
    void testDeleteMessage() throws Exception {
        // Create queue with name delete-message-test
        String createdUrl = sqsService.createQueue(BATCH_QUEUE_TEST);
        assertNotNull(createdUrl);

        // Send batch messages into the queue

        SQSSendMessageBatchRequest messageBatchRequest = getSqsSendMessageBatchRequest(createdUrl);

        SQSMessageBatchResponse sendMessageBatchResult = sqsService.sendMessageBatch(messageBatchRequest);
        assertNotNull(sendMessageBatchResult);

        // Read messages from the queue
        SQSReceiveMessageRequest receiveMessageRequest = SQSReceiveMessageRequest.builder()
                .queueUrl(createdUrl)
                .maxNumberOfMessages(2)
                .waitTimeSeconds(1)
                .build();
        List<SQSMessage> messages = sqsService.receiveMessage(receiveMessageRequest).getMessages();

        assertEquals(2, messages.size());
        SQSMessage msg = messages.getFirst();
        assertEquals("First batch message", msg.getBody());

        // Delete message by batch
        SQSDeleteMessageBatchRequest deleteMessageBatchRequest = getSqsDeleteMessageBatchRequest(messages, createdUrl);

        sqsService.deleteMessageBatch(deleteMessageBatchRequest);

        // Read queue after deleting the messages by batch
        List<SQSMessage> emptyMessages = sqsService.receiveMessage(receiveMessageRequest).getMessages();
        assertTrue(emptyMessages.isEmpty(), "Queue should be empty after deleting the messages by batch.");
    }

    private SQSDeleteMessageBatchRequest getSqsDeleteMessageBatchRequest(List<SQSMessage> messages, String createdUrl) {
        List<SQSDeleteMessageBatchRequestEntry> deleteMsgEntries = new ArrayList<>();

        deleteMsgEntries.add(SQSDeleteMessageBatchRequestEntry.builder()
                .id(messages.getFirst().getMessageId())
                .receiptHandle(messages.getFirst().getReceiptHandle())
                .build());

        deleteMsgEntries.add(SQSDeleteMessageBatchRequestEntry.builder()
                .id(messages.getLast().getMessageId())
                .receiptHandle(messages.getLast().getReceiptHandle())
                .build());

        return SQSDeleteMessageBatchRequest.builder()
                .queueUrl(createdUrl)
                .entries(deleteMsgEntries)
                .build();
    }

    private SQSSendMessageBatchRequest getSqsSendMessageBatchRequest(String createdUrl) {
        List<SQSSendMessageBatchRequestEntry> batchMessages = new ArrayList<>();
        batchMessages.add(SQSSendMessageBatchRequestEntry.builder()
                .id("id-1")
                .messageBody("First batch message")
                .build());
        batchMessages.add(SQSSendMessageBatchRequestEntry.builder()
                .id("id-2")
                .messageBody("Second batch message")
                .build());

        return  SQSSendMessageBatchRequest.builder()
                .queueUrl(createdUrl)
                .entries(batchMessages)
                .build();
    }

    @Test
    void testSendAndDeleteMessageBatch() throws Exception {
        // Create queue with name delete-message-test
        String createdUrl = sqsService.createQueue(DELETE_MESSAGE_TEST);
        assertNotNull(createdUrl);

        // Send a message into the queue
        String messageToBeDeleted = "Test message to be deleted";

        SQSSendMessageRequest sendMessageRequest = SQSSendMessageRequest.builder()
                .queueUrl(createdUrl)
                .messageBody(messageToBeDeleted)
                .build();
        sqsService.sendMessage(sendMessageRequest);

        SQSReceiveMessageRequest receiveMessageRequest = SQSReceiveMessageRequest.builder()
                .queueUrl(createdUrl)
                .build();

        // Read message from the queue before deleting
        List<SQSMessage> messages = sqsService.receiveMessage(receiveMessageRequest).getMessages();
        SQSMessage msg = messages.getFirst();
        assertEquals(messageToBeDeleted, msg.getBody(), "Sent message present in queue.");

        // Delete message from the queue
        sqsService.deleteMessage(createdUrl, msg.getReceiptHandle());

        // Read queue after deleting the message
        List<SQSMessage> emptyMessages = sqsService.receiveMessage(receiveMessageRequest).getMessages();
        assertTrue(emptyMessages.isEmpty(), "Queue should be empty after deleting the message.");
        sqsService.shutdown();
    }

}

can any required logic of local stack or test containers be lifted from this? one of my seniors wrote this
