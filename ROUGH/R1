give me an integration test for :
package com.personalcapital.salesforce.sps.repository;

import com.personalcapital.salesforce.sps.enums.RegistrationStatus;
import com.personalcapital.salesforce.sps.entity.SpsCirrusContactMetadata;

import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Slice;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collection;
import java.util.List;
import java.util.UUID;

@Repository
public interface SpsCirrusContactMetadataRepository
		extends JpaRepository<SpsCirrusContactMetadata, UUID>
{
	@Transactional(readOnly = true)
	SpsCirrusContactMetadata findByMetadataId(UUID metadataId);

	@Transactional(readOnly = true)
	Slice<SpsCirrusContactMetadata> findByRegistrationStatus(
            RegistrationStatus registrationStatus, Pageable pageable);

	@Transactional(readOnly = true)
	@Query("select m from SpsCirrusContactMetadata m where m.metadataId in :metadataIds")
	List<SpsCirrusContactMetadata> findExistingUsersByMetadataId(@Param("metadataIds") Collection<UUID> metadataIds);

	@Transactional(readOnly = true)
	List<SpsCirrusContactMetadata> findByUserAccountGuidAndPersonaId(UUID userAccountGuid, UUID personaId);

	@Transactional(readOnly = true)
	@Query(value = "SELECT hash_value FROM sp_schema.sps_cirrus_contact_metadata WHERE user_account_guid = :userAccountGuid ORDER BY updated_date DESC LIMIT 1",
			nativeQuery = true)
	Integer findLatestHashByUserAccountGuid(@Param("userAccountGuid") UUID userAccountGuid);

	@Modifying(clearAutomatically = true, flushAutomatically = true)
	@Transactional
	@Query("update SpsCirrusContactMetadata m set m.registrationStatus = :status " + "where m.userAccountGuid = :userAccountGuid and m.personaId = :personaId")
	int setStatus(@Param("userAccountGuid") UUID userAccountGuid, @Param("personaId") UUID personaId,
                  @Param("status") RegistrationStatus registrationStatus);

	@Modifying
	@Transactional
	@Query("update SpsCirrusContactMetadata m set m.retryCount = m.retryCount + 1 where m.metadataId = :metadataId")
	int incrementRetry(@Param("metadataId") UUID metadataId);

	// getEntriesByStatus(registrationStatus)
	@Transactional(readOnly = true)
	List<SpsCirrusContactMetadata> findAllByRegistrationStatus(RegistrationStatus status);
}


entity:
package com.personalcapital.salesforce.sps.entity;

import com.personalcapital.data.repository.BaseEntity;
import com.personalcapital.salesforce.sps.enums.DataSource;
import com.personalcapital.salesforce.sps.enums.DataSourceConverter;
import com.personalcapital.salesforce.sps.enums.RegistrationStatus;
import com.personalcapital.salesforce.sps.enums.UserSpsPlanType;
import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.GenericGenerator;

import java.util.Date;
import java.util.UUID;

@Data
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(callSuper = true)
@Entity
@Table(name = "sps_cirrus_contact_metadata", catalog = "sp_schema")
public class SpsCirrusContactMetadata extends BaseEntity
{
	@Id
	@GeneratedValue(generator = "uuid2")
	@GenericGenerator(name = "uuid2", strategy = "org.hibernate.id.UUIDGenerator")
	@Column(name = "metadata_id", columnDefinition = "BINARY(16)")
	private UUID metadataId;

	@Column(name = "user_account_guid", columnDefinition = "BINARY(16)")
	private UUID userAccountGuid;

	@Column(name = "persona_id", columnDefinition = "BINARY(16)")
	private UUID personaId;

	@Column(name = "hash_value")
	private Integer hashValue;

	@Column(name = "persona_details_json", columnDefinition = "JSON")
	private String personaAltIds;

	@Convert(converter = DataSourceConverter.class)
	@Column(name = "data_source", columnDefinition = "ENUM('ACCOUNT','C&H')")
	private DataSource dataSource;

	@Column(name = "user_sps_plan_type") // enum1
	@Enumerated(EnumType.STRING)
	private UserSpsPlanType userSpsPlanType;

	@Column(name = "registration_status")
	@Enumerated(EnumType.STRING)
	private RegistrationStatus registrationStatus;

	@Column(name = "retry_count")
	private int retryCount;

	@Column(name = "created_date")
	private Date createdDate;

	@Column(name = "updated_date")
	private Date updatedDate;

	public SpsCirrusContactMetadata(UUID metadataId, UUID userAccountGuid, UUID personaId,
									UserSpsPlanType userSpsPlanType, RegistrationStatus registrationStatus)
	{
		this.metadataId = metadataId;
		this.userAccountGuid = userAccountGuid;
		this.personaId = personaId;
		this.userSpsPlanType = userSpsPlanType;
		this.registrationStatus = registrationStatus;
	}
}

enums:
package com.personalcapital.salesforce.sps.enums;

public enum DataSource
{
	ACCOUNT("ACCOUNT"),C_AND_H("C&H");

	private final String dbValue;
	DataSource(String dbValue) { this.dbValue = dbValue; }
	public String getDbValue() { return dbValue; }

	public static DataSource fromDb(String v) {
		if (v == null) return null;
		return switch (v) {
			case "ACCOUNT" -> ACCOUNT;
			case "C&H" -> C_AND_H;
			default -> throw new IllegalArgumentException("Unknown data_source: " + v);
		};
	}
}

package com.personalcapital.salesforce.sps.enums;

import jakarta.persistence.AttributeConverter;
import jakarta.persistence.Converter;

@Converter(autoApply = false)
public class DataSourceConverter implements AttributeConverter<DataSource, String> {
    @Override
    public String convertToDatabaseColumn(DataSource attribute) {
        return attribute == null ? null : attribute.getDbValue();
    }

    @Override
    public DataSource convertToEntityAttribute(String dbData) {
        return DataSource.fromDb(dbData);
    }
}

package com.personalcapital.salesforce.sps.enums;

public enum UserSpsPlanType
{
	CONFORMING, NON_CONFORMING
}

package com.personalcapital.salesforce.sps.enums;

public enum RegistrationStatus
{
	COMPLETED, EXPIRED, FAILED, PENDING
}


reference test of something that is already working:
/**
 * Test class for EmployerRepository
 */
package com.personalcapital.data.repository.employer;

import org.junit.jupiter.api.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.annotation.Rollback;
import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;
import org.springframework.test.context.junit4.AbstractTransactionalJUnit4SpringContextTests;
import org.springframework.transaction.annotation.Transactional;

import com.personalcapital.employer.Employer;

/**
 * @author npenugonda
 */
// @Ignore
@Rollback
@Transactional(value = "spTran")
@SpringJUnitConfig(locations = "classpath:persistenceApplicationContext.xml")

public class EmployerRepositoryTest
{
	@Autowired
	private EmployerRepository employerRepository;

	@BeforeEach
	public void setUp() throws Exception
	{
		Employer emp = new Employer();
		emp.setEin("123");
		emp.setName("TestEmp");
		emp.setZipcode("94085");
		emp.setVendorEmployerId("1111");
		employerRepository.save(emp);

		Employer emp1 = new Employer();
		emp1.setEin("456");
		emp1.setName("TestEmp1");
		emp1.setZipcode("94086");
		emp1.setVendorEmployerId("2222");
		employerRepository.save(emp1);
	}

	@AfterEach
	public void tearDown() throws Exception
	{
	}

	@Test
	@Disabled
	public void testFindAll()
	{
		Iterable<Employer> emp = employerRepository.findAll();
		Assertions.assertNotNull(emp.iterator()
				.next());
		Employer empTest = emp.iterator()
				.next();
		Assertions.assertTrue(empTest.getEin()
				.equals("123"));
		Assertions.assertTrue(empTest.getName()
				.equals("TestEmp"));
		Assertions.assertTrue(empTest.getZipcode()
				.equals("94085"));
	}

	@Test
	public void testFindEmployerByEin()
	{
		Employer employer = employerRepository.findEmployerByEin("123");
		Assertions.assertNotNull(employer);
		Assertions.assertNotNull(employer.getName());
	}

	@Test
	public void testFindEmployerByEinAndName()
	{
		Employer emp = employerRepository.findEmployerByEinAndName("123", "TestEmp");
		Assertions.assertNotNull(emp);
		Assertions.assertNotNull(emp.getId());
	}

	@Test
	public void testUpsertEmployerRepository()
	{
		int val = employerRepository.upsertEmployer("123", "TestEmp", "95087");
		Assertions.assertTrue(val >= 0);
	}

	@Test
	public void testFindEmployerByEinAndNameAndSponsor()
	{
		Employer emp = employerRepository.findEmployerByEinAndNameAndVendorEmployeeId("123",
				"TestEmp", "1111");
		Assertions.assertNotNull(emp);
		Assertions.assertNotNull(emp.getId());
	}

	public void testInsertEmployerRepositoryWithVendorEmployerId()
	{
		employerRepository.insertEmployer("789", "TestEmp2", "95088", "3333");
		Employer employer = employerRepository.findEmployerByEinAndName("789", "TestEmp2");
		Assertions.assertEquals("3333", employer.getVendorEmployerId());
		Assertions.assertEquals("95088", employer.getZipcode());
	}

	@Test
	public void testUpdateEmployerRepositoryWithVendorEmployerId()
	{
		Employer employer = employerRepository.findEmployerByEinAndNameAndVendorEmployeeId("456",
				"TestEmp1", "2222");
		employer.setEin("654");
		employer.setName("TestEmp3");
		employer.setZipcode("68049");
		employer.setVendorEmployerId("4444");
		employerRepository.updateEmployer(employer.getEin(), employer.getName(),
				employer.getZipcode(), employer.getVendorEmployerId(), employer.getId());
		Employer employerFromDB = employerRepository.findEmployerByEinAndNameAndVendorEmployeeId(
				employer.getEin(), employer.getName(), employer.getVendorEmployerId());
		Assertions.assertEquals(employer.getName(), employerFromDB.getName());
		Assertions.assertEquals(employer.getEin(), employerFromDB.getEin());
		Assertions.assertEquals(employer.getVendorEmployerId(),
				employerFromDB.getVendorEmployerId());
		Assertions.assertEquals(employer.getZipcode(), employerFromDB.getZipcode());
	}

	@Test
	public void findEmployerByVendorEmployerId()
	{
		Employer employer = employerRepository.findEmployerByVendorEmployerId("1111");
		Assertions.assertNotNull(employer);
		Assertions.assertNotNull(employer.getName());
	}

}

persistenceApplicationContext.xml:
<?xml version="1.0" encoding="UTF-8"?>
<beans default-lazy-init="true" xmlns="http://www.springframework.org/schema/beans"
	   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	   xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd"
	   xmlns:context="http://www.springframework.org/schema/context">

	<import resource="file:${TEST_CONFIG_HOME}/spring/sp-base-test.xml" />

	<import resource="classpath:pcap-data-agent.xml" />
	<import resource="classpath:pcap-dao.xml" />
	<import resource="classpath:account-api-client.xml" />


	<bean id="redissonConfiguration" class="com.personalcapital.cache.config.RedissonConfiguration">
		<property name="enabled" value="true" />
	</bean>
	<!-- To make sure cryptEngine is not mocked for this test context -->
	<import resource="classpath*:sp-security.xml"/>
	<bean id="applicationContextProvider" class="com.personalcapital.context.ApplicationContextProvider" />

	<bean id="tagDao" class="com.personalcapital.user.data.impl.TagDaoImpl"/>
	<bean id="userDao" class="com.safepage.user.data.impl.UserDaoImpl" />
	<bean id="userTagDao" class="com.personalcapital.user.data.impl.UserTagDaoImpl" />
	<context:component-scan base-package="com.empower.epw.repository, com.empower.epw.config" />
</beans>

