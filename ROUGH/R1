package com.empower.epw.crm.gateway.sqs.config;

import java.time.Duration;
import java.util.UUID;
import java.util.concurrent.ThreadPoolExecutor;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.messaging.Message; // <-- IMPORT ADDED
import org.springframework.messaging.MessageHeaders; // <-- IMPORT ADDED
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;

// We no longer need CrmProcessingService in this class
import com.empower.epw.crm.gateway.sqs.MessageException; // <-- YOUR EXCEPTION
import io.awspring.cloud.sqs.listener.errorhandler.ErrorHandler;
import lombok.CustomLog;
import io.awspring.cloud.sqs.MessageExecutionThreadFactory;
import io.awspring.cloud.sqs.config.SqsMessageListenerContainerFactory;
import io.awspring.cloud.sqs.listener.QueueNotFoundStrategy;
import io.awspring.cloud.sqs.listener.acknowledgement.handler.AcknowledgementMode;
import software.amazon.awssdk.services.sqs.SqsAsyncClient;

@CustomLog
@Configuration
@ConditionalOnProperty(name = "crm.gateway.listener.enabled", havingValue = "true", matchIfMissing = false)
public class CrmGatewaySqsConfig
{
	@Value("${crm.gateway.sqs.visibilityTimeout:60}")
	public Integer visibilityTimeout;

	@Value("${crm.gateway.sqs.minPoolSize:10}")
	public Integer minPoolSize;

	@Value("${crm.gateway.sqs.maxPoolSize:30}")
	public Integer maxPoolSize;

	@Value("${crm.gateway.sqs.queueCapacity:30}")
	public Integer queueCapacity;

	@Value("${crm.gateway.sqs.queueMaxAwaitTermination:30}")
	public Integer queueMaxAwaitTermination;

	@Value("{crm.gateway.sqs.retry.backoff.delay:60000}")
	public Long backoffDelay;

	@Value("{crm.gateway.sqs.retry.max.attempts:3}")
	public Integer maxAttempts;

	@Bean("awsTaskExecutor")
	public ThreadPoolTaskExecutor awsTaskExecutor()
	{
		ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
		executor.setCorePoolSize(minPoolSize);
		executor.setMaxPoolSize(maxPoolSize);
		executor.setQueueCapacity(queueCapacity);
		executor.setWaitForTasksToCompleteOnShutdown(true);
		executor.setAwaitTerminationSeconds(queueMaxAwaitTermination);
		executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
		executor.setThreadFactory(new MessageExecutionThreadFactory("crmGatewaySqsThread-"));
		return executor;
	}

	/**
	 * This error handler now inspects the EXCEPTION TYPE to decide what to do.
	 * - MessageException: Re-throws the error. This signals failure to SQS,
	 * which will eventually move the message to the DLQ.
	 * - Other Exceptions: Swallows the error. This signals success to SQS,
	 * which will DELETE the message (preventing it from going to the DLQ).
	 */
	@Bean
	public ErrorHandler<Object> customErrorHandler() { // <-- No CrmProcessingService
		return new ErrorHandler<Object>() {
			@Override
			public void handle(Message<Object> msg, Throwable t) {
				MessageHeaders headers = msg.getHeaders();
				UUID messageId = headers.getId();
				String messageIdString = (messageId != null) ? messageId.toString() : "unknown";

				// Check the cause of the exception
				Throwable cause = t.getCause();

				// Task: Identify MessageException and send ONLY that to DLQ
				if (cause instanceof MessageException) {
					log.error("Poison pill detected via exception. ID: {}. Re-throwing to send to DLQ.",
							messageIdString, cause.getMessage());

					// Re-throw the exception to signal failure (sends to DLQ)
					if (t instanceof RuntimeException) {
						throw (RuntimeException) t;
					}
					throw new RuntimeException("SQS processing failed for poison pill", t);

				} else {
					// This is a different, unexpected error (e.g., NullPointerException).
					// We log it but DO NOT re-throw. This "handles" the error
					// and the message will be deleted (NOT sent to the DLQ).
					log.warn("Unexpected SQS processing error (not poison pill). ID: {}. Payload: {}. Swallowing error, message will be deleted.",
							messageIdString, msg.getPayload(), t);
					// By not re-throwing, we are "handling" the error.
				}
			}
		};
	}

	@Bean
	SqsMessageListenerContainerFactory<Object> defaultSqsListenerContainerFactory(
			SqsAsyncClient sqsAsyncClient, ErrorHandler<Object> customErrorHandler) // <-- MODIFIED: Inject handler
	{

		log.info("Creating SQS Listener Container Factory with visibility timeout: {}",
				visibilityTimeout);

		return SqsMessageListenerContainerFactory.builder()
				.sqsAsyncClient(sqsAsyncClient)
				// Tell the factory to use our new error handler
				.errorHandler(customErrorHandler) // <-- ADDED
				.configure(sqsContainerOptionsBuilder -> sqsContainerOptionsBuilder
						.messageVisibility(Duration.ofSeconds(visibilityTimeout))
						.queueNotFoundStrategy(QueueNotFoundStrategy.FAIL)
						.pollTimeout(Duration.ofSeconds(20))
						.maxMessagesPerPoll(10)
						.componentsTaskExecutor(awsTaskExecutor())
						.autoStartup(true)
						// This is key: we only acknowledge on success.
						// By re-throwing, we are not successful.
						.acknowledgementMode(AcknowledgementMode.ON_SUCCESS))
				.build();
	}
}
