Task in hand:
A SlowTest annotation was added to the UserInfoDaoTest. I believe we had an issue with UserInfoDaoTest.testGetMaxEligibleUserInfoIdForRefreshedBalances() based on cursory investigation in PLAT-7822.

This test class needs to be refactored so we can:

successfully run the test locally
successfully run the test on Jenkins without creating a bunch of junk data in the Devtrunk DB


/**
 * 
 */
package com.personalcapital.user.data;

import java.util.Date;
import java.util.List;

import org.apache.commons.collections4.CollectionUtils;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.annotation.Rollback;

import com.personalcapital.user.data.impl.NotesForAdvisor;
import com.personalcapital.user.data.impl.Strategy;
import com.personalcapital.user.data.impl.StrategyDataStore;
import com.personalcapital.user.data.impl.UserMetroCode;
import com.personalcapital.user.data.impl.UserMetroCodeDataStore;
import com.personalcapital.user.data.impl.UserMetroCodeDataStore.UserMetroCodeSource;
import com.personalcapital.user.data.impl.UserTimeZone;
import com.personalcapital.user.data.impl.UserTimeZoneDataStore;
import com.personalcapital.user.data.impl.UserTimeZoneDataStore.UserTimeZoneSource;
import com.personalcapital.user.data.impl.profilevalue.InvestibleAssetData;
import com.personalcapital.user.data.impl.profilevalue.InvestibleAssetDataStore;
import com.personalcapital.user.data.impl.profilevalue.ProfileValueDataStore.ProfileValueSource;
import com.personalcapital.user.data.util.UserDataUtils;
import com.safepage.exception.SafePageException;
import com.safepage.json.JSONObject;
import com.safepage.user.data.BaseDaoTest;
import com.safepage.user.data.User;
import com.safepage.user.data.UserDao;
import com.safepage.util.DateTimeUtils;
import com.safepage.util.Utils;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;

/**
 * @author Rohit Iyer
 * @since Apr 2, 2013
 */
@Rollback(false)
// @Disabled
//@Tag("SlowTest")
public class UserInfoDaoTest extends BaseDaoTest
{
	@Autowired
	private UserInfoDao userInfoDao;

	@Autowired
	private UserDataUtils userDataUtils;

	@Autowired
	private UserDao userDao;

	private final String TEST_USER = "testid1pc@gmail.com";

	protected User initializeUser(String email) throws Exception
	{
		User user = null;
		user = userDao.getUserByName(email);
		if (user == null)
		{
			user = userDataUtils.createUser(email);
		}
		return user;
	}

	protected UserInfo initializeUserInfo(User user) throws Exception
	{
		UserInfo userInfo = userInfoDao.getUserInfoByUserId(user.getId());
		if (userInfo == null)
		{
			userInfo = userDataUtils.addUserInfoForUser(user);
		}

		return userInfo;
	}

	@Test
	@Rollback(true)
	public void testStrategyDataStore() throws Exception
	{

		User user = initializeUser(TEST_USER);
		assertNotNull(user);

		UserInfo userInfo = initializeUserInfo(user);
		assertNotNull(userInfo);

		MultiSourceDataStore dataStore = (StrategyDataStore) userInfo.strategyDataStore();
		Strategy master = (Strategy) dataStore.retrieve();
		if (master != null)
		{
			master.setIsRevoked(true);

			dataStore.save(master);
			Strategy newMaster = (Strategy) dataStore.retrieve();
			assertNotEquals(master, newMaster);
		}
	}

	@Test
	@Rollback(true)
	public void testTimeZoneDataStore() throws Exception
	{
		User user = initializeUser(TEST_USER);
		assertNotNull(user);

		UserInfo userInfo = initializeUserInfo(user);
		assertNotNull(userInfo);

		UserTimeZone userTimeZone = UserTimeZoneDataStore.createUserTimeZone("America/Los_Angeles",
				UserTimeZoneSource.USER);

		userInfo.saveUserTimeZone(userTimeZone);
		UserInfo userInfoUpdated = userDataUtils.saveUserInfo(userInfo);
		assertNotNull(userInfoUpdated, "userInfoUpdated can't be null");
		UserTimeZone userTimeZoneUpdated = userInfoUpdated.getUserTimeZone();
		assertNotNull(userTimeZoneUpdated, "userTimeZoneUpdated can't be null");
	}

	@Test
	@Rollback(true)
	public void testUserTimeZoneDataStore() throws Exception
	{
		User user = initializeUser(TEST_USER);
		assertNotNull(user);

		UserInfo userInfo = initializeUserInfo(user);
		assertNotNull(userInfo);

		UserTimeZone userTimeZone = UserTimeZoneDataStore.createUserTimeZone("US/Pacific",
				UserTimeZoneSource.PHYSICAL_ADDRESS);

		userInfo.saveUserTimeZone(userTimeZone);

		userInfo = userDataUtils.saveUserInfo(userInfo);

		UserTimeZone master = userInfo.getUserTimeZone();

		assertEquals(master, userTimeZone);
	}

	@Test
	@Rollback(true)
	public void testUserMetroCodeDataStore() throws Exception
	{
		User user = initializeUser(TEST_USER);
		assertNotNull(user);

		UserInfo userInfo = initializeUserInfo(user);
		assertNotNull(userInfo);

		UserMetroCode userMetroCode = UserMetroCodeDataStore.createUserMetroCode(1,
				UserMetroCodeSource.PHONE);

		userInfo.saveUserMetroCode(userMetroCode);

		userDataUtils.saveUserInfo(userInfo);

		UserMetroCode master = userInfo.getUserMetroCode();

		assertNotNull(master);
	}

	@Test
	@Rollback(true)
	public void testInvestibleAssetDataStore() throws Exception
	{
		User user = initializeUser(TEST_USER);
		assertNotNull(user);

		UserInfo userInfo = initializeUserInfo(user);
		assertNotNull(userInfo);

		Double value = System.currentTimeMillis() % 10000.0;

		InvestibleAssetData calculatedProfileValue = InvestibleAssetDataStore
				.createInvestibleAssetData(value, ProfileValueSource.CALCULATED);

		userInfo.saveInvestibleAssetProfileValue(calculatedProfileValue);

		userDataUtils.saveUserInfo(userInfo);

		InvestibleAssetData master = userInfo.getInvestibleAssetProfileValue();

		assertNotNull(master);

		assertEquals(master.getValue(), value);

		JSONObject jsonPerson = userInfo.getInvestibleAssetDataStore()
				.toPersonJson();
		assertNotNull(jsonPerson);

		assertEquals(jsonPerson.get("investableAssets"), value);
	}

	@Test
	public void validateTolerance()
	{
		double oldValue = 100.0;
		double newValue = 104.9;

		assertTrue(Utils.equalsWithinTolerance(oldValue, newValue, 5.0),
				"Not in Tolerance but passed check.");

		newValue = 95.5;
		assertTrue(Utils.equalsWithinTolerance(oldValue, newValue, 5.0),
				"Not in Tolerance but passed check.");

		newValue = 100.0;
		assertTrue(Utils.equalsWithinTolerance(oldValue, newValue, 5.0),
				"Not in Tolerance but passed check.");

		newValue = 105.0;
		assertTrue(Utils.equalsWithinTolerance(oldValue, newValue, 5.0));

		newValue = 95.0;
		assertTrue(Utils.equalsWithinTolerance(oldValue, newValue, 5.0));

		newValue = 92.0;
		assertTrue(Utils.equalsWithinTolerance(oldValue, newValue, 5.0));

		newValue = 115.0;
		assertTrue(Utils.equalsWithinTolerance(oldValue, newValue, 5.0));
	}

	@Test
	public void testNotesForAdvisor() throws Exception
	{
		User user = initializeUser("testid1pc@gmail.com");
		assertNotNull(user);
		UserInfo userInfo = userDataUtils.getUserInfoForUser(user);
		assertNotNull(userInfo);

		NotesForAdvisor notesForAdvisorBackup = userInfo.getNotesForAdvisor();

		NotesForAdvisor notesForAdvisor = new NotesForAdvisor();
		userInfo.setNotesForAdvisor(notesForAdvisor);
		userDataUtils.saveUserInfo(userInfo);

		userInfo.setNotesForAdvisor(notesForAdvisorBackup);
		userDataUtils.saveUserInfo(userInfo);
	}

	@Test
	public void testGetEligibleUsersForAumBalanceRefresh() throws SafePageException
	{
		List<UserInfo> userInfoList = userInfoDao.getEligibleUsersForAumBalanceRefresh(null, 0L,
				50);
		assertNotNull(userInfoList);
		assertTrue(userInfoList.isEmpty() == false);
	}

	@Test
	public void numberOfLoanAccountsTest() throws Exception
	{
		User user = initializeUser(TEST_USER);
		assertNotNull(user);

		UserInfo userInfo = initializeUserInfo(user);
		assertNotNull(userInfo);

		Integer testValue = 2;
		userInfo.setNumberOfLoanAccounts(testValue);

		Long userInfoId = userInfoDao.save(userInfo)
				.getId();
		UserInfo userInfoFromDB = userInfoDao.getUserInfoByUserId(user.getId());
		assertEquals(testValue, userInfoFromDB.getNumberOfLoanAccounts(),
				"Number of Loan accounts doesn't persist correctly ");
	}

	@Test
	public void numberOfMortgageAccountsTest() throws Exception
	{
		User user = initializeUser(TEST_USER);
		assertNotNull(user);

		UserInfo userInfo = initializeUserInfo(user);
		assertNotNull(userInfo);

		Integer testValue = 4;
		userInfo.setNumberOfMortgageAccounts(testValue);

		Long userInfoId = userInfoDao.save(userInfo)
				.getId();
		UserInfo userInfoFromDB = userInfoDao.getUserInfoByUserId(user.getId());
		assertEquals(testValue, userInfoFromDB.getNumberOfMortgageAccounts(),
				"Number of mortgage accounts doesn't persist correctly ");
	}

	@Test
	public void testGetMaxEligibleUserInfoIdForRefreshedBalances()
	{
		Date current = new Date();
		Long empty = userInfoDao.getMaxEligibleUserInfoIdForRefreshedBalances(current,
				DateTimeUtils.getDaysInPast(current, 1), 10000);

		assertEquals(empty, Long.valueOf(0));

		Long tillnow = userInfoDao.getMaxEligibleUserInfoIdForRefreshedBalances(null, current,
				10000);
		assertTrue(tillnow > 0);
	}

	@Test
	public void testUpdateUserSuspiciousDate() throws Exception
	{
		User user = initializeUser(TEST_USER);
		assertNotNull(user);

		UserInfo userInfo = initializeUserInfo(user);
		assertNotNull(userInfo);

		int updated = userInfoDao.updateUserSuspiciousDate(user, false);
		assertEquals(updated, 1);
	}

	@Test
	public void testGetEligibleUsersForRefreshedBalancesForNonMigratedUser() throws Exception
	{
		// initialize user & userInfo
		Date endDate = DateTimeUtils.getDateInFutureByDays(2L);
		int minimumInvestibleBalance = 0;

		User user = initializeUser(TEST_USER);
		assertNotNull(user);

		UserInfo userInfo = initializeUserInfo(user);
		assertNotNull(userInfo);

		Boolean isMigratedOriginal = user.getIsMigrated();
		String tenantNameOriginal = user.getTenantName();
		Date lastNetworthUpdatedDateOriginal = userInfo.getLastNetworthUpdatedDate();
		Long startUserInfoId = userInfo.getId();
		long endUserInfoId = startUserInfoId + 1;

		userInfo.setLastNetworthUpdatedDate(DateTimeUtils.getCurrentTime());
		userInfo = userInfoDao.save(userInfo);

		// Non-migrated user
		user.setIsMigrated(null);
		user = userDao.getEntityManager()
				.merge(user);
		userDao.getEntityManager()
				.flush();

		List<UserInfo> result = userInfoDao.getEligibleUsersForRefreshedBalances(null, endDate,
				minimumInvestibleBalance, startUserInfoId, endUserInfoId);

		assertTrue(CollectionUtils.isNotEmpty(result));
		assertEquals(1, result.size());
		assertEquals(startUserInfoId, result.get(0)
				.getId());

		// reset test data to old values
		userInfo.setLastNetworthUpdatedDate(lastNetworthUpdatedDateOriginal);
		user.setIsMigrated(isMigratedOriginal);
		user.setTenantName(tenantNameOriginal);
		userDao.getEntityManager()
				.merge(user);
		userInfoDao.save(userInfo);
	}

	@Test
	public void testGetEligibleUsersForRefreshedBalancesForMigratedAffiliatUser() throws Exception
	{
		// initialize user & userInfo
		Date endDate = DateTimeUtils.getDateInFutureByDays(2L);
		int minimumInvestibleBalance = 0;

		User user = initializeUser(TEST_USER);
		assertNotNull(user);

		UserInfo userInfo = initializeUserInfo(user);
		assertNotNull(userInfo);

		Boolean isMigratedOriginal = user.getIsMigrated();
		String tenantNameOriginal = user.getTenantName();
		Date lastNetworthUpdatedDateOriginal = userInfo.getLastNetworthUpdatedDate();
		Long startUserInfoId = userInfo.getId();
		long endUserInfoId = startUserInfoId + 1;

		userInfo.setLastNetworthUpdatedDate(DateTimeUtils.getCurrentTime());
		userInfo = userInfoDao.save(userInfo);

		// Migrated affiliate user
		user.setIsMigrated(true);
		user.setTenantName("EMPOWER");
		user = userDao.getEntityManager()
				.merge(user);
		userDao.getEntityManager()
				.flush();

		List<UserInfo> result = userInfoDao.getEligibleUsersForRefreshedBalances(null, endDate,
				minimumInvestibleBalance, startUserInfoId, endUserInfoId);

		assertTrue(CollectionUtils.isNotEmpty(result));
		assertEquals(1, result.size());
		assertEquals(startUserInfoId, result.get(0)
				.getId());

		// reset test data to old values
		userInfo.setLastNetworthUpdatedDate(lastNetworthUpdatedDateOriginal);
		user.setIsMigrated(isMigratedOriginal);
		user.setTenantName(tenantNameOriginal);
		userDao.getEntityManager()
				.merge(user);
		userInfoDao.save(userInfo);
	}

	@Test
	public void testGetEligibleUsersForRefreshedBalancesForMigratedD2CUser() throws Exception
	{
		// initialize user & userInfo
		Date endDate = DateTimeUtils.getDateInFutureByDays(2L);
		int minimumInvestibleBalance = 0;

		User user = initializeUser(TEST_USER);
		assertNotNull(user);

		UserInfo userInfo = initializeUserInfo(user);
		assertNotNull(userInfo);

		Boolean isMigratedOriginal = user.getIsMigrated();
		String tenantNameOriginal = user.getTenantName();
		Date lastNetworthUpdatedDateOriginal = userInfo.getLastNetworthUpdatedDate();
		Long startUserInfoId = userInfo.getId();
		long endUserInfoId = startUserInfoId + 1;

		userInfo.setLastNetworthUpdatedDate(DateTimeUtils.getCurrentTime());
		userInfo = userInfoDao.save(userInfo);

		// Migrated d2c user
		user.setIsMigrated(true);
		user.setTenantName(null);
		user = userDao.getEntityManager()
				.merge(user);
		userDao.getEntityManager()
				.flush();

		List<UserInfo> result = userInfoDao.getEligibleUsersForRefreshedBalances(null, endDate,
				minimumInvestibleBalance, startUserInfoId, endUserInfoId);

		assertTrue(CollectionUtils.isEmpty(result));

		// reset test data to old values
		userInfo.setLastNetworthUpdatedDate(lastNetworthUpdatedDateOriginal);
		user.setIsMigrated(isMigratedOriginal);
		user.setTenantName(tenantNameOriginal);
		userDao.getEntityManager()
				.merge(user);
		userInfoDao.save(userInfo);
	}

	@Test
	public void testGetEligibleUsersForRefreshedBalancesWhenIsMigratedIsFalse() throws Exception
	{
		// initialize user & userInfo
		Date endDate = DateTimeUtils.getDateInFutureByDays(2L);
		int minimumInvestibleBalance = 0;

		User user = initializeUser(TEST_USER);
		assertNotNull(user);

		UserInfo userInfo = initializeUserInfo(user);
		assertNotNull(userInfo);

		Boolean isMigratedOriginal = user.getIsMigrated();
		String tenantNameOriginal = user.getTenantName();
		Date lastNetworthUpdatedDateOriginal = userInfo.getLastNetworthUpdatedDate();
		Long startUserInfoId = userInfo.getId();
		long endUserInfoId = startUserInfoId + 1;

		userInfo.setLastNetworthUpdatedDate(DateTimeUtils.getCurrentTime());
		userInfo = userInfoDao.save(userInfo);

		// When isMigrated is false
		user.setIsMigrated(false);
		user = userDao.getEntityManager()
				.merge(user);
		userDao.getEntityManager()
				.flush();

		List<UserInfo> result = userInfoDao.getEligibleUsersForRefreshedBalances(null, endDate,
				minimumInvestibleBalance, startUserInfoId, endUserInfoId);

		assertTrue(CollectionUtils.isEmpty(result));

		// reset test data to old values
		userInfo.setLastNetworthUpdatedDate(lastNetworthUpdatedDateOriginal);
		user.setIsMigrated(isMigratedOriginal);
		user.setTenantName(tenantNameOriginal);
		userDao.getEntityManager()
				.merge(user);
		userInfoDao.save(userInfo);
	}

	@Test
	public void testGetUserInfosWithNotesForAdvisor()
	{
		List<UserInfo> userInfos = userInfoDao.getUserInfosWithNotesForAdvisor(0, 1000);
		assertNotNull(userInfoDao);
		assertTrue(userInfos.getFirst()
				.getId() < userInfos.get(1)
						.getId());
		assertTrue(userInfos.size() > 0, "Size shouldn't be zero");
	}

	@Test
	public void testGetMaxUserInfoId()
	{
		Long maxId = userInfoDao.getMaxUserInfoId();
		assertNotNull(maxId);
	}

	@Test
	public void testGetNextMinUserInfoId() throws Exception
	{

		User user = initializeUser("testuser1234@test.com");
		assertNotNull(user);

		UserInfo userInfo = initializeUserInfo(user);
		assertNotNull(userInfo);

		Long userInfoId = userInfo.getId();

		Long result = userInfoDao.getNextMinUserInfoId(userInfoId - 1);
		assertEquals(userInfoId, result);
	}

}



1) Caused by: java.sql.SQLSyntaxErrorException: Unknown column 'ui1_0.registration_source' in 'field list'
--> alter table sp_schema.user add column registration_source varchar(20) DEFAULT 'PCAP';

2) Caused by: java.sql.SQLSyntaxErrorException: Unknown column 'ui1_0.is_mcw_strategy' in 'field list'
--> alter table sp_schema.user_info add column is_mcw_strategy varchar(20) DEFAULT 'PCAP';

3) ERROR org.hibernate.engine.jdbc.spi.SqlExceptionHelper - Cannot determine value type from string 'PCAP'
--> alter table sp_schema.user_info ALTER COLUMN is_mcw_strategy DROP DEFAULT;

4) ERROR org.hibernate.engine.jdbc.spi.SqlExceptionHelper - Cannot determine value type from string 'PCAP'
   Caused by: java.sql.SQLIntegrityConstraintViolationException: Duplicate entry '364' for key 'user_info.userinfo_userid_uidx'
org.hibernate.exception.ConstraintViolationException: could not execute statement [Duplicate entry '364' for key 'user_info.userinfo_userid_uidx'] [insert into sp_schema.user_info (`100k_qualified_date`,advisory_fee_percentage,asset_alternatives_percentage,asset_alternatives_value,asset_cash_percentage,asset_cash_value,asset_intl_bonds_percentage,asset_intl_bonds_value,asset_intl_stocks_percentage,asset_intl_stocks_value,asset_unclassified_percentage,asset_unclassified_value,asset_us_bonds_percentage,asset_us_bonds_value,asset_us_stocks_percentage,asset_us_stocks_value,aum_balance,aum_balance_last_updated_date,classification_by_asset,classification_by_sector,classification_by_type,existing_advisor,fund_fee_percentage,geoip_area_code,geoip_city,geoip_country_code,geoip_history,geoip_metro_code,geoip_postal_code,geoip_region,geoip_time_zone,idle_cash,investible_assets,investible_asset_detail,investible_asset_outside_value,investible_asset_value_date,investible_asset_source,investible_asset_value,is_bogus_number,is_internal,is_invalid,is_investment_client,is_mcw_strategy,is_no_assignment,is_sri_strategy,is_test,last_networth_updated_date,liquid_portfolio,manual_asset_value,mylife_ratio_of_miss,mylife_retirement_amount_ratio,networth,networth_value,notes_for_advisor,number_of_bank_accounts,number_of_credit_card_accounts,number_of_investment_accounts,number_of_loan_accounts,number_of_mortgage_accounts,opportunity_stage,portable_asset_detail,portable_asset_last_synched,portable_asset_value,portable_asset_expiration,portable_asset_last_updated,portable_share_of_wallet,portable_asset_source,primary_portfolio_goal,priority_level,strategy_last_synched,strategy_expected_withdrawal_rate,strategy_return_needed,suspicious_as_of_date,target_portfolio,taxable_portfolio_value,total_share_of_wallet,transaction_tags,user_id,user_metro_code_detail,user_metro_code_last_synched,user_metro_code_expiration,user_metro_code_last_updated,user_metro_code_value,user_metro_code_source,user_portfolio_expected_return,user_portfolio_expected_std_dev,user_portfolio_value,user_time_zone_detail,user_time_zone_last_synched,user_time_zone_expiration,user_time_zone_last_updated,user_time_zone_name,user_time_zone_source,you_index) values (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)]
