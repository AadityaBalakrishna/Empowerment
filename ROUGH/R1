previously the exceptions were captured like this:
public String encryptUsingAWSKey(String plainText, String keyId) throws SafePageException
	{
		if (StringUtils.isEmpty(plainText))
		{
			throw new SafePageException(SafePageErrorType.INVALID_INPUT, "plainText is required!");
		}
		if (StringUtils.isEmpty(keyId))
		{
			throw new SafePageException(SafePageErrorType.INVALID_INPUT, "keyId is required!");
		}
		try
		{
			EncryptRequest encryptRequest = new EncryptRequest().withKeyId(keyId)
					.withPlaintext(getByteBuffer(plainText));
			long start = System.currentTimeMillis();
			EncryptResult result = getKMSClient().encrypt(encryptRequest);
			if (result != null && result.getCiphertextBlob() != null)
			{
				long end = System.currentTimeMillis();
				logger.info("encryptData took {} " + (end - start));
				return Utils.encodeBase64(result.getCiphertextBlob()
						.array());
			}
			logger.error("encryptUsingAWSKey failed, EncryptResult is null!");
			return null;
		}
		catch (DisabledException de)
		{
			logger.error(
					"Failed to encryptUsingAWSKey(DisabledException), plainText:{}, keyId:{}, due to:{}",
					plainText, keyId, ExceptionUtils.getMessage(de), de);
		}
		catch (KeyUnavailableException kue)
		{
			logger.error(
					"Failed to encryptUsingAWSKey(KeyUnavailableException), plainText:{}, keyId:{}, due to:{}",
					plainText, keyId, ExceptionUtils.getMessage(kue), kue);
		}
		catch (Exception ex)
		{
			logger.error("Failed to encryptUsingAWSKey, plainText:{}, keyId:{}, due to:{}",
					plainText, keyId, ExceptionUtils.getMessage(ex), ex);
		}
		return null;
	}


now:
	public String encryptUsingAWSKey(String plainText, String keyId) throws SafePageException
	{
		if (StringUtils.isEmpty(plainText))
		{
			throw new SafePageException(SafePageErrorType.INVALID_INPUT, "plainText is required!");
		}
		if (StringUtils.isEmpty(keyId))
		{
			throw new SafePageException(SafePageErrorType.INVALID_INPUT, "keyId is required!");
		}
		try
		{
			EncryptRequest encryptRequest = new EncryptRequest().withKeyId(keyId)
					.withPlaintext(getByteBuffer(plainText));
			long start = System.currentTimeMillis();
			EncryptResult result = kmsClient.encrypt(encryptRequest);
			if (result != null && result.getCiphertextBlob() != null)
			{
				long end = System.currentTimeMillis();
				logger.info("[{}] encryptData took {} ", getAwsSdkVersion(), end - start);
				return Utils.encodeBase64(result.getCiphertextBlob()
						.array());
			}
			else
			{
				logger.error("[{}] encryptUsingAWSKey failed, EncryptResult is null for keyId: {}",
						getAwsSdkVersion(), keyId);
				throw AwsExceptionHandler.handleKMSException("encrypt", keyId,
						new IllegalStateException("EncryptResult or CiphertextBlob is null"));
			}
		}
		catch (DisabledException | KeyUnavailableException | UnsupportedEncodingException ex)
		{
			logger.error("[{}] Failed to encrypt, plainText:{}, keyId:{}, due to:{}",
					getAwsSdkVersion(), plainText, keyId, ExceptionUtils.getMessage(ex), ex);
			throw AwsExceptionHandler.handleKMSException("encrypt", keyId, ex);
		}
	}


package com.empower.epw.aws.api.kms.exception;

public class KMSOperationException extends RuntimeException
{
	public KMSOperationException(String message, Throwable cause)
	{
		super(message, cause);
	}
}

package com.empower.epw.aws.v1.kms.util;

import com.empower.epw.aws.api.kms.exception.KMSOperationException;
import com.personalcapital.log.PcapLogger;
import com.personalcapital.log.PcapLoggerFactory;

public class AwsExceptionHandler
{
	public static final String FAILURE_MSG_PREFIX = "[AWS SDK v1] Failed to ";

	private static final PcapLogger logger = PcapLoggerFactory
			.getPcapLogger(AwsExceptionHandler.class);

	public static KMSOperationException handleKMSException(String operation, String keyId,
			Exception e)
	{
		String errorMessage = String.format("'%s' KMS operation '%s' failed for keyId '%s': %s",
				FAILURE_MSG_PREFIX, keyId, e.getMessage());
		logger.error(errorMessage, e);
		return new KMSOperationException(errorMessage, e);
	}
}




i feel there's something off with this, can you help me figure out if the previous style of exception handling is still followed, if not what's missing and whats new?
