	public ListAliasesResponseDTO listAliases()
	{
		try
		{
			ListAliasesResult result = kmsClient
					.listAliases(new ListAliasesRequest().withLimit(100));
			List<ListAliasesResponseDTO.AliasEntry> aliasEntries = result.getAliases()
					.stream()
					.map(alias -> new ListAliasesResponseDTO.AliasEntry(alias.getAliasName(),
							alias.getTargetKeyId()))
					.collect(Collectors.toList());
			return new ListAliasesResponseDTO(aliasEntries);
		}
		catch (Exception ex)
		{
			logger.error(String.format("[%s] Failed to listAliases, due to:%s", getAwsSdkVersion(),
					ExceptionUtils.getMessage(ex)), ex);
			return new ListAliasesResponseDTO();
		}
	}


for this method i got a review comment:
if not throwing exception how consumers get error scenario communicated?


the old method:
	public ListAliasesResult getKeyAliases(String keyId)
	{
		ListAliasesRequest listAliasesRequest = new ListAliasesRequest().withLimit(10);
		ListAliasesResult result = getKMSClient().listAliases(listAliasesRequest);
		return result;
	}

refactored old method:
	public ListAliasesResult getKeyAliases(String keyId)
	{
		ListAliasesResponseDTO dto = epwKmsService.listAliases();

		List<AliasListEntry> aliasEntries = dto.getAliases()
				.stream()
				.map(alias -> new AliasListEntry().withAliasName(alias.getAliasName())
						.withTargetKeyId(alias.getTargetKeyId()))
				.collect(Collectors.toList());

		return new ListAliasesResult().withAliases(aliasEntries);
	}


main point to notice here is the old delegates to new and it shouldn't break any consumers
