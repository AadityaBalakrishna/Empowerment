@SuppressWarnings("unchecked")
@Around("@annotation(pcapMultiCacheable)")
public Object doMultiCacheable(ProceedingJoinPoint pjp, PcapMultiCacheable pcapMultiCacheable) throws Throwable {
    Method method = null;
    Object[] args = pjp.getArgs();
    Class<?> returnType = null;
    Integer listKeyArgIndex = null;
    Collection<Object> listKeyArg = new ArrayList<>();
    Collection<Object> otherKeyArgs = new ArrayList<>();
    Collection<Object> missedListKeys = null;
    Object[] modifiedArgs = null;
    boolean resultIsCollection = true;

    String resultKeyField = pcapMultiCacheable.resultKeyField();
    String[] resultKeyFields = pcapMultiCacheable.resultKeyFields();
    boolean cachedValueNullable = pcapMultiCacheable.nullable();
    String keyPrefix = pcapMultiCacheable.keyPrefix();
    Collection<Object> collectionResult = null;
    Map<Object, Object> mapResult = null;

    Map<Object, Object> keyValueMap = new LinkedHashMap<>();
    String cacheName = pcapMultiCacheable.value();
    RedisType redisType = pcapMultiCacheable.redisType();

    if (StringUtils.isBlank(cacheName)) {
        throw new AopInvocationException("pcapMultiCacheable needs to have cacheName specified.");
    }

    CacheKeyProvider cacheKeyProvider = pcapMultiCacheable.keyProvider().getDeclaredConstructor().newInstance();

    try {
        method = CacheAdviceHelper.getMethod(pjp);
        returnType = method.getReturnType();

        if (Collection.class.isAssignableFrom(returnType)) {
            resultIsCollection = true;
            collectionResult = collectionInstance((Class<? extends Collection>) returnType);
        } else if (Map.class.isAssignableFrom(returnType)) {
            resultIsCollection = false;
            mapResult = mapInstance((Class<? extends Map>) returnType);
        } else {
            throw new AopInvocationException("pcapMultiCacheable cannot apply to method without return.");
        }

        int[] keyIndice = pcapMultiCacheable.keys();
        if (args == null || args.length == 0) {
            throw new AopInvocationException("pcapMultiCacheable cannot apply to method without parameters.");
        }

        for (int i = 0; i < args.length; i++) {
            Object arg = args[i];
            if (Collection.class.isInstance(arg) && Collection.class.isAssignableFrom(arg.getClass())) {
                listKeyArgIndex = i;
            } else {
                otherKeyArgs.add(cacheKeyProvider.getKeyField(arg));
            }
        }

        if (listKeyArgIndex == null) {
            throw new AopInvocationException("pcapMultiCacheable must have a Collection parameter as key list.");
        }

        listKeyArg = (Collection<Object>) args[listKeyArgIndex];

        for (Object listKey : listKeyArg) {
            String key = CacheUtils.generateKey(cacheName, keyPrefix, cacheKeyProvider.getKeyField(listKey), otherKeyArgs);
            Object cachedValue = getRedisson(redisType).getBucket(key).get();

            if (cachedValue == null || (cachedValue instanceof ObjectUtils.Null && !cachedValueNullable)) {
                if (missedListKeys == null) {
                    missedListKeys = collectionInstance(listKeyArg.getClass());
                }
                missedListKeys.add(listKey);
            } else {
                keyValueMap.put(listKey, CacheUtils.getValue(cachedValue));

                // **Cache Hit Metric**
                logger.info("Cache hit in class: {}, method: {}", pjp.getTarget().getClass().getSimpleName(), pjp.getSignature().getName());
                Metrics.counter("pcap.cache.event",
                        "class", pjp.getTarget().getClass().getSimpleName(),
                        "method", pjp.getSignature().getName(),
                        "outcome", "hit").increment();
            }
        }

        if (missedListKeys == null || missedListKeys.isEmpty()) {
            return resultIsCollection ? getCollectionResult(listKeyArg, keyValueMap, collectionResult)
                    : getMapResult(listKeyArg, keyValueMap, mapResult);
        }

        // **Cache Miss Metric**
        logger.info("Cache miss in class: {}, method: {}", pjp.getTarget().getClass().getSimpleName(), pjp.getSignature().getName());
        Metrics.counter("pcap.cache.event",
                "class", pjp.getTarget().getClass().getSimpleName(),
                "method", pjp.getSignature().getName(),
                "outcome", "miss").increment();

        modifiedArgs = modifiedArgs(args, listKeyArgIndex, missedListKeys);
    } catch (Exception ex) {
        logger.info("Caching on {} aborted due to an error. message: {}. stacktrace: {}",
                pjp.toShortString(), ex.getMessage(), ExceptionUtils.getStackTrace(ex));

        // **Cache Failure Metric**
        Metrics.counter("pcap.cache.event",
                "class", pjp.getTarget().getClass().getSimpleName(),
                "method", pjp.getSignature().getName(),
                "outcome", "failure").increment();

        return pjp.proceed();
    }

    final Object resultForMissed = pjp.proceed(modifiedArgs);
    int ttlSeconds = getTtlFromConfiguration(cacheName, pcapMultiCacheable.ttlSeconds());

    try {
        if (resultIsCollection) {
            Collection<Object> collectionResultForMissed = (Collection<Object>) resultForMissed;

            Collection<Object> mergedResult = getCollectionResult(listKeyArg, keyValueMap, collectionResult);
            if (collectionResultForMissed == null || collectionResultForMissed.isEmpty()) {
                return mergedResult;
            }

            for (Object resultItemForMissed : collectionResultForMissed) {
                if (resultItemForMissed == null) continue;

                String cacheKey = CacheUtils.generateKey(cacheName, keyPrefix, cacheKeyProvider.getKeyField(resultItemForMissed), otherKeyArgs);
                getRedisson(redisType).getBucket(cacheKey).set(resultItemForMissed, ttlSeconds, TimeUnit.SECONDS);

                mergedResult.add(resultItemForMissed);
            }

            return mergedResult;
        } else {
            Map<Object, Object> mapResultForMissed = (Map<Object, Object>) resultForMissed;
            Map<Object, Object> mergedResult = getMapResult(listKeyArg, keyValueMap, mapResult);

            if (mapResultForMissed == null || mapResultForMissed.isEmpty()) {
                return mergedResult;
            }

            for (Object key : missedListKeys) {
                Object value = mapResultForMissed.get(key);
                String cacheKey = CacheUtils.generateKey(cacheName, keyPrefix, cacheKeyProvider.getKeyField(key), otherKeyArgs);
                getRedisson(redisType).getBucket(cacheKey).set(value == null ? ObjectUtils.NULL : value, ttlSeconds, TimeUnit.SECONDS);
                mergedResult.put(key, value);
            }

            return mergedResult;
        }
    } catch (Exception ex) {
        logger.info("Cache processing failed in class: {}, method: {}. Error: {}",
                pjp.getTarget().getClass().getSimpleName(), pjp.getSignature().getName(), ex.getMessage());

        // **Cache Processing Failure Metric**
        Metrics.counter("pcap.cache.event",
                "class", pjp.getTarget().getClass().getSimpleName(),
                "method", pjp.getSignature().getName(),
                "outcome", "processing-failure").increment();

        return pjp.proceed();
    }
}