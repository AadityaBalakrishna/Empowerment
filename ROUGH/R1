Review Comments:
Please don't remove old methods, public DescribeKeyResult describeKey(String awsCmkKeyAlias); and public ListAliasesResult getKeyAliases(String awsCmkKeyAlias);
behavior changes. 
in old: if result is null, we will return null, 
but now, if result is null, we throwing custom exception
in old:  when an exception like DisabledException | KeyUnavailableException | UnsupportedEncodingException
we log error and return null, but now we are throwing exception
 
public void testGetAliasListForKey() throws Exception, Here also we throwing exception, in old we are not throwing 

this should be used
logger.error("[{}] Failed to encrypt, plainText:{}, keyId:{}, due to:{}",
       getAwsSdkVersion(), plainText, keyId, ExceptionUtils.getMessage(ex), ex);
refer S3Impl ( logger.error - using different overload method 
void error(String format, Object... args);
from PcapLogger, which don't print stackTrace
void error(String msg, Throwable thrown);

so those two deprecated methods i should keep it as it is, in both KMSService and KMSServiceImpl ? ---> yeah mark as Deprecated for old method, keep the new methods ( remove Deprecated ) 

old KMSService:
package com.safepage.security.service;
import com.amazonaws.services.kms.model.DescribeKeyResult;
import com.amazonaws.services.kms.model.ListAliasesResult;
import com.safepage.exception.SafePageException;
public interface KMSService
{
	public String encryptUsingAWSKey(String plainText, String keyId) throws SafePageException;
	public String decryptUsingAWSKey(String cipherText) throws SafePageException;
	public ListAliasesResult getKeyAliases(String awsCmkKeyAlias);
	public DescribeKeyResult describeKey(String awsCmkKeyAlias);
}

new KMSService:
package com.safepage.security.service;
import com.amazonaws.services.kms.model.DescribeKeyResult;
import com.amazonaws.services.kms.model.ListAliasesResult;
import com.empower.epw.aws.api.kms.dto.DescribeKeyResponseDTO;
import com.empower.epw.aws.api.kms.dto.ListAliasesResponseDTO;
import com.safepage.exception.SafePageException;
public interface KMSService
{
	public String encryptUsingAWSKey(String plainText, String keyId) throws SafePageException;
	public String decryptUsingAWSKey(String cipherText) throws SafePageException;
	@Deprecated
	public ListAliasesResponseDTO getKeyAliases(String awsCmkKeyAlias) throws SafePageException;
	@Deprecated
	public DescribeKeyResponseDTO describeKey(String awsCmkKeyAlias) throws SafePageException;
}

old KMSServiceImpl:
package com.safepage.security.service.impl;
public class KMSServiceImpl implements KMSService
{
	private AWSKMS kmsClient = null;
	private static PcapLogger logger = PcapLoggerFactory.getPcapLogger(KMSServiceImpl.class);
	private static Charset charset = StandardCharsets.UTF_8;
	private AWSKMS getKMSClient()
	{
		if (kmsClient == null)
		{
			AWSCredentialsManager awsCredentialsManager = new AWSCredentialsManager();
			kmsClient = (AWSKMS) awsCredentialsManager
					.getClientBuilderWithCredentials(AWSKMSClient.builder())
					.build();
		}
		return kmsClient;
	}

	// private constructor
	private KMSServiceImpl()
	{
		/*
		 * 1. can only be initialized using inner static class on first access.
		 */
		logger.info("Initialized the KMSServiceImpl");
	}

	/*
	 * Bill Pugh Singleton creation using static inner class, thread safe and no synchronized block
	 */
	private static class KMSServiceHolder
	{
		private static final KMSService INSTANCE = new KMSServiceImpl();
	}

	public static KMSService getInstance()
	{
		/*
		 * only when someone calls the method, this class gets loaded and creates the Singleton
		 * class instance
		 */
		return KMSServiceHolder.INSTANCE;

	}

	/**
	 * Encrypt data key (system secondary key) under AWS CMK Key using IAM role to access the key
	 * AWS CMK
	 *
	 * @throws SafePageException
	 */
	@Override
	// @Retryable(value =
	// {
	// Exception.class
	// }, maxAttempts = 3, backoff = @Backoff(delay = 1000))
	public String encryptUsingAWSKey(String plainText, String keyId) throws SafePageException
	{
		if (StringUtils.isEmpty(plainText))
		{
			throw new SafePageException(SafePageErrorType.INVALID_INPUT, "plainText is required!");
		}
		if (StringUtils.isEmpty(keyId))
		{
			throw new SafePageException(SafePageErrorType.INVALID_INPUT, "keyId is required!");
		}
		try
		{
			EncryptRequest encryptRequest = new EncryptRequest().withKeyId(keyId)
					.withPlaintext(getByteBuffer(plainText));
			long start = System.currentTimeMillis();
			EncryptResult result = getKMSClient().encrypt(encryptRequest);
			if (result != null && result.getCiphertextBlob() != null)
			{
				long end = System.currentTimeMillis();
				logger.info("encryptData took {} " + (end - start));
				return Utils.encodeBase64(result.getCiphertextBlob()
						.array());
			}
			logger.error("encryptUsingAWSKey failed, EncryptResult is null!");
			return null;
		}
		catch (DisabledException de)
		{
			logger.error(
					"Failed to encryptUsingAWSKey(DisabledException), plainText:{}, keyId:{}, due to:{}",
					plainText, keyId, ExceptionUtils.getMessage(de), de);
		}
		catch (KeyUnavailableException kue)
		{
			logger.error(
					"Failed to encryptUsingAWSKey(KeyUnavailableException), plainText:{}, keyId:{}, due to:{}",
					plainText, keyId, ExceptionUtils.getMessage(kue), kue);
		}
		catch (Exception ex)
		{
			logger.error("Failed to encryptUsingAWSKey, plainText:{}, keyId:{}, due to:{}",
					plainText, keyId, ExceptionUtils.getMessage(ex), ex);
		}
		return null;
	}

	/**
	 * Decrypt encrypted data key under AWS CMK Key using IAM role to access the key
	 */
	@Override
	// @Retryable(value =
	// {
	// Exception.class
	// }, maxAttempts = 3, backoff = @Backoff(delay = 1000))
	public String decryptUsingAWSKey(String cipherText) throws SafePageException
	{
		if (StringUtils.isEmpty(cipherText))
		{
			throw new SafePageException(SafePageErrorType.INVALID_INPUT, "cipherText is required!");
		}
		try
		{
			byte[] decodedCipherText = Utils.decodeBase64(cipherText);
			DecryptRequest decryptRequest = new DecryptRequest()
					.withCiphertextBlob(ByteBuffer.wrap(decodedCipherText));
			long start = System.currentTimeMillis();
			DecryptResult result = getKMSClient().decrypt(decryptRequest);
			long end = System.currentTimeMillis();
			logger.info("decryptData took {}" + (end - start));
			ByteBuffer plainTextBlob = result.getPlaintext();
			return getString(plainTextBlob);
		}
		catch (KeyUnavailableException kue)
		{
			// The request was rejected because the specified CMK was not available. The request can
			// be retried.
			logger.error(
					"Failed to decryptUsingAWSKey(KeyUnavailableException), cipherText:{}, due to:{}",
					cipherText, ExceptionUtils.getMessage(kue), kue);
		}
		catch (InvalidCiphertextException ice)
		{
			// The request was rejected because the specified ciphertext, or additional
			// authenticated data incorporated
			// into the ciphertext, such as the encryption context, is corrupted, missing, or
			// otherwise invalid.
			logger.error(
					"Failed to decryptUsingAWSKey(InvalidCiphertextException), cipherText:{}, due to:{}",
					cipherText, ExceptionUtils.getMessage(ice), ice);
		}
		catch (DisabledException de)
		{
			logger.error(
					"Failed to decryptUsingAWSKey(DisabledException), cipherText:{}, due to:{}",
					cipherText, ExceptionUtils.getMessage(de), de);
		}
		catch (Exception ex)
		{
			logger.error("Failed to decryptUsingAWSKey, cipherText:{}, due to:{}", cipherText,
					ExceptionUtils.getMessage(ex), ex);
		}

		return null;
	}

	public static String getString(ByteBuffer byteBuffer)
	{
		byte[] byteArray = new byte[byteBuffer.remaining()];
		byteBuffer.get(byteArray);
		return new String(byteArray, charset);
	}

	public static ByteBuffer getByteBuffer(String string)
	{
		return ByteBuffer.wrap(string.getBytes(charset));
	}

	@Override
	public DescribeKeyResult describeKey(String keyId)
	{
		DescribeKeyRequest describeKeyRequest = new DescribeKeyRequest().withKeyId(keyId);
		DescribeKeyResult result = getKMSClient().describeKey(describeKeyRequest);
		return result;
	}

	@Override
	public ListAliasesResult getKeyAliases(String keyId)
	{
		ListAliasesRequest listAliasesRequest = new ListAliasesRequest().withLimit(10);
		ListAliasesResult result = getKMSClient().listAliases(listAliasesRequest);
		return result;
	}
}

New KMSServiceImpl which delegates to the new EpwKmsService:
package com.safepage.security.service.impl;
public class KMSServiceImpl implements KMSService
{
	private static final PcapLogger logger = PcapLoggerFactory.getPcapLogger(KMSServiceImpl.class);

	private final EpwKmsService epwKmsService;

	@Autowired
	public KMSServiceImpl(@Qualifier("epwKmsService") EpwKmsService epwKmsService)
	{
		this.epwKmsService = epwKmsService;
	}

	public String encryptUsingAWSKey(String plainText, String keyId) throws SafePageException
	{
		if (StringUtils.isEmpty(plainText))
		{
			throw new SafePageException(SafePageErrorType.INVALID_INPUT, "plainText is required!");
		}
		if (StringUtils.isEmpty(keyId))
		{
			throw new SafePageException(SafePageErrorType.INVALID_INPUT, "keyId is required!");
		}

		String cipherText = epwKmsService.encryptUsingAWSKey(plainText, keyId);

		if (StringUtils.isEmpty(cipherText))
		{
			logger.error("KMS encryption returned null or empty ciphertext.");
			return null;
		}
		return cipherText;
	}


	public String decryptUsingAWSKey(String cipherText) throws SafePageException
	{
		if (StringUtils.isEmpty(cipherText))
		{
			throw new SafePageException(SafePageErrorType.INVALID_INPUT, "cipherText is required!");
		}

		String plaintext = epwKmsService.decryptUsingAWSKey(cipherText);

		if (StringUtils.isEmpty(plaintext))
		{
			logger.error("KMS decryption returned null or empty plaintext.");
			throw new SafePageException(SafePageErrorType.INVALID_INPUT, "Decryption failed.");
		}

		return plaintext;
	}

	@Override
	@Deprecated
	public DescribeKeyResponseDTO describeKey(String keyId) throws SafePageException
	{
		return epwKmsService.describeKey(keyId);
	}

	@Override
	@Deprecated
	public ListAliasesResponseDTO getKeyAliases(String keyId) throws SafePageException
	{
		return epwKmsService.listAliases();
	}
}
