package com.empower.epw.trs.consumer;

import java.util.List;
import java.util.Optional;

import org.springframework.retry.annotation.Backoff;
import org.springframework.retry.annotation.Recover;
import org.springframework.retry.annotation.Retryable;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import io.awspring.cloud.sqs.annotation.SqsListener;

import com.empower.epw.trs.mapper.MetadataMapper;
import com.empower.epw.trs.service.AccountRefreshService;
import com.empower.epw.trs.service.MetadataService;
import com.empower.epw.trs.stream.TrsPublishStream;
import com.empower.epw.trs.util.JsonUtils;
import com.empower.ihub.sps.common.Metadata;
import com.empower.ihub.sps.refresh.RefreshEvent;
import com.personalcapital.log.PcapLogger;
import com.personalcapital.log.PcapLoggerFactory;
import com.safepage.aggregation.data.PayLoad;
import com.safepage.aggregation.data.impl.AggregationQueueImpl;

import lombok.RequiredArgsConstructor;

@Component
@RequiredArgsConstructor
@Transactional(value = "epwTrsTransactionManager", propagation = Propagation.REQUIRES_NEW)
public class TrsSqsConsumer
{

	private static final PcapLogger logger = PcapLoggerFactory.getPcapLogger(TrsSqsConsumer.class);

	private static final String METADATA = "metadata";

	private final TrsPublishStream trsPublishStream;

	private final MetadataService metadataService;

	private final MetadataMapper metadataMapper;

	private final AccountRefreshService accountRefreshService;

	@SqsListener(value = "${trs.sqs.queue.normal:}")
	@Retryable(value =
	{
			Exception.class
	}, maxAttemptsExpression = "#{${trs.sqs.retry.max-attempts:3}}", backoff = @Backoff(delayExpression = "#{${trs.sqs.retry.backoff-delay:1000}}"))
	public void onMessage(final AggregationQueueImpl message)
	{
		logger.info("Consume SQS message for Confirming User, Message is:" + message.getPayload());

		try
		{

			final Metadata spsMetadata = this.createSpsMetadata(message);

			if (spsMetadata == null)
			{
				return;
			}

			this.metadataService
					.saveSuccess(this.metadataMapper.spsMetadataToMetadata(spsMetadata));

			final List<RefreshEvent> refreshEvents = this.accountRefreshService
					.buildRefreshEventsForUser(message, spsMetadata);

			refreshEvents.forEach(this.trsPublishStream::publishEvent);

		}
		catch (Exception e)
		{
			logger.error("Error on consuming trs sqs message: ", e);
			throw e;
		}
	}

	private Metadata createSpsMetadata(final AggregationQueueImpl message)
	{
		return JsonUtils.fromJsonSnakeCase(
				Optional.of(this.accountRefreshService.getPayloadFromAggregationQueue(message))
						.map(PayLoad::getJsonObject)
						.filter(object -> object.has(METADATA))
						.map(object -> object.getString(METADATA))
						.orElse(null),
				Metadata.class);
	}

	@Recover
	public void recoverOnMessageRetryFailure(RuntimeException e, final AggregationQueueImpl message)
	{

		final Metadata spsMetadata = this.createSpsMetadata(message);

		if (spsMetadata != null)
		{
			logger.info("The processing of SQS message failed on all retries for trace id :"
					+ spsMetadata.getTraceId());
			Optional.ofNullable(this.metadataMapper.spsMetadataToMetadata(spsMetadata))
					.ifPresent(m -> metadataService.saveFailure(m, e.getMessage()));
		}

	}

}


can i use something like this? i was told to refer to this 
