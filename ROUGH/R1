package com.safepage.security;

import java.nio.ByteBuffer;
import java.security.Key;
import java.security.SecureRandom;
import java.security.Security;
import java.security.spec.AlgorithmParameterSpec;
import java.util.concurrent.TimeUnit;

import javax.crypto.Cipher;
import javax.crypto.spec.GCMParameterSpec;
import jakarta.annotation.PostConstruct;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.time.StopWatch;
import org.apache.commons.pool2.BasePooledObjectFactory;
import org.apache.commons.pool2.ObjectPool;
import org.apache.commons.pool2.PooledObject;
import org.apache.commons.pool2.impl.DefaultPooledObject;
import org.apache.commons.pool2.impl.GenericObjectPool;
import org.apache.commons.pool2.impl.GenericObjectPoolConfig;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.ApplicationListener;
import org.springframework.context.event.ContextRefreshedEvent;

import com.empower.epw.security.Decryptor;
import com.empower.epw.security.Encryptor;
import com.google.common.annotations.VisibleForTesting;
import com.personalcapital.config.AppType;
import com.personalcapital.config.ServerConfigurer;
import com.personalcapital.log.PcapLogger;
import com.personalcapital.log.PcapLoggerFactory;
import com.safepage.exception.JSONException;
import com.safepage.exception.SafePageException;
import com.safepage.json.JSONObject;
import com.safepage.security.KeyManager.KeyData;
import com.safepage.security.UserPrimaryKeyContext.UserPrimaryKey;
import com.safepage.security.service.impl.KMSServiceImpl;
import com.safepage.thread.SafePageExecutor;
import com.safepage.user.data.AuthUser;
import com.safepage.util.Utils;

import static com.safepage.security.CryptType.MODE;

/**
 * Handles encyption and decr<br>
 * Encryption Algorithm: AES<br>
 * PRNG Algorithm: Sha1<br>
 * Seed length: 32<br>
 * Key length: 256<br>
 */
public class CryptEngine implements ApplicationListener<ContextRefreshedEvent>, Encryptor, Decryptor
{
	protected static PcapLogger logger = PcapLoggerFactory.getPcapLogger(CryptEngine.class);

	@Value("${user.seed.minIdlePoolsize:10}")
	private int minIdleSeedPoolSize;

	@Value("${user.seed.maxIdlePoolsize:50}")
	private int maxIdleUserSeedPoolSize;

	@Value("${user.seed.maxPoolsize:1000}")
	private int maxUserSeedPoolSize;

	@Value("${user.seed.timeBetweenEvictionRunsInSeconds:30}")
	private int timeBetweenEvictionRunsInSeconds;

	static final String SAFEPAGE_USER_ID = "SAFEPAGE_USER_ID";
	static final String SAFEPAGE_PAYLOAD = "SAFEPAGE_PAYLOAD";

	public static final int GCM_INITIAL_VECTOR_LENGTH_BYTE = 12;
	public static final int GCM_AUTHENTICATION_TAG_LENGTH_BITS = 128;

	private final int MINIMUM_LENGTH_FOR_ENCRYPTED_STRINGS = 24;

	@Autowired
	private BeanFactory beanFactory;

	private KeyManager keyManager;

	private ObjectPool<String> pool;

	private SafePageExecutor spExecutor;

	/**
	 * A simple factory that generates encrypted user keys. There is no use for implementing
	 * destroyObject, validateObject, activateObject and passivateObject
	 */
	protected class EncryptedUserSeedFactory extends BasePooledObjectFactory<String>
	{
		@Override
		public String create()
		{
			try
			{
				String userPrimarySeed = getKeyManager().generateNewSeedValue();
				String encryptedSeed = encrypt(CryptType.SYSTEM_SECONDARY, userPrimarySeed);
				if (Utils.isNull(encryptedSeed))
				{
					throw new Exception(
							"generateUserPrimaryKey failed since encryptedSeed is null.");
				}
				return encryptedSeed;
			}
			catch (Exception e)
			{
				throw new RuntimeException("EncryptedUserSeedFactory failed: ", e);
			}
		}

		@Override
		public PooledObject<String> wrap(String obj)
		{
			return new DefaultPooledObject<String>(obj);
		}
	}

	/*
	 * Used by junits
	 */
	public void setKeyManager(KeyManager keyManager)
	{
		this.keyManager = keyManager;
	}

	protected KeyManager getKeyManager()
	{
		if (keyManager == null)
		{
			keyManager = (KeyManager) beanFactory.getBean("keyManager");
		}
		return keyManager;
	}

	protected SafePageExecutor getSafePageExecutor()
	{
		if (this.spExecutor == null)
		{
			this.spExecutor = (SafePageExecutor) beanFactory.getBean("spExecutor");
		}
		return this.spExecutor;
	}

	@PostConstruct
	public void init() throws Exception
	{
		// From: https://golb.hplar.ch/2017/10/JCE-policy-changes-in-Java-SE-8u151-and-8u152.html
		Security.setProperty("crypto.policy", "unlimited");
		CryptEngineFacade.setCryptEngine(this);
		try
		{
			logger.info("initializing CryptEngine; SYSTEM_PRIMARY key version is: "
					+ CryptType.SYSTEM_PRIMARY.getVersion());
			logger.info("initializing CryptEngine; SYSTEM_SECONDARY key version is: "
					+ CryptType.SYSTEM_SECONDARY.getVersion());
			logger.info("initializing CryptEngine; USER_PRIMARY key version is: "
					+ CryptType.USER_PRIMARY.getVersion());
			logger.info("initializing CryptEngine; USER_SECONDARY key version is: "
					+ CryptType.USER_SECONDARY.getVersion());
			logger.info(
					"initializing user seed pool minIdleSeedPoolSize:{},maxIdleSeedPoolSize:{},maxUserSeedPoolSize:{},timeBetweenEvictionRunsInSeconds:{} ",
					minIdleSeedPoolSize, maxIdleUserSeedPoolSize, maxUserSeedPoolSize,
					timeBetweenEvictionRunsInSeconds);

			if (System.getProperty("SKIP_CRYPT_POOL") != null)
			{
				this.minIdleSeedPoolSize = 1;
				this.maxIdleUserSeedPoolSize = 2;
				this.maxUserSeedPoolSize = 5;
				this.timeBetweenEvictionRunsInSeconds = 10;
				return;
			}

			this.getKeyManager()
					.getDefaultSystemSecondaryKey();

		}
		catch (Exception e)
		{
			logger.error("Error initializing CryptEngine: " + e.getMessage(), e);
		}
	}

	/**
	 * PLAT-3354: Reduce startup time by optimizing keyseed initialization only for ROOT
	 */
	@Override
	public void onApplicationEvent(ContextRefreshedEvent applicationEvent)
	{
		try
		{
			ServerConfigurer serverConfigurer = (ServerConfigurer) beanFactory
					.getBean("serverConfigurer");
			if (serverConfigurer == null || serverConfigurer.isDevOrLocalEnvironment()
					|| AppType.ROOT != serverConfigurer.getAppType())
			{
				return;
			}

			logger.info("Initializing KeySeed pool");

			CreatePrimaryKeySeed createPrimaryKeySeed = new CreatePrimaryKeySeed();
			this.getSafePageExecutor()
					.execute(createPrimaryKeySeed);
		}
		catch (BeansException ex)
		{
			// bean not found
		}
	}

	public String getVersion(CryptType cryptType)
	{
		return cryptType != null ? cryptType.getVersion() : null;
	}

	/**
	 * create generic object pool config
	 * 
	 * @return poolConfig
	 */
	protected GenericObjectPoolConfig createGenericObjectPoolConfig()
	{
		GenericObjectPoolConfig poolConfig = new GenericObjectPoolConfig();
		poolConfig.setMinIdle(minIdleSeedPoolSize);
		poolConfig.setMaxIdle(maxIdleUserSeedPoolSize);
		poolConfig.setMaxTotal(maxUserSeedPoolSize);
		poolConfig.setTimeBetweenEvictionRunsMillis(
				TimeUnit.SECONDS.toMillis(timeBetweenEvictionRunsInSeconds));
		poolConfig.setBlockWhenExhausted(false);
		return poolConfig;
	}

	/**
	 * Class used to create primary key seed of pool
	 * 
	 * @author jponsekar
	 */
	protected class CreatePrimaryKeySeed implements Runnable
	{
		public void run()
		{
			try
			{
				/*
				 * Initialize the EncryptedUserSeed pool by setting the pool size and the
				 * replenishing period.
				 */
				StopWatch stopWatch = new StopWatch();
				stopWatch.start();
				GenericObjectPoolConfig poolConfig = createGenericObjectPoolConfig();
				pool = new GenericObjectPool<String>(new EncryptedUserSeedFactory(), poolConfig);
				for (int i = 0; i < poolConfig.getMaxIdle(); i++)
				{
					pool.addObject();
				}
				logger.info("KeySeed pool initialization completed in {} ms.", stopWatch.getTime());
			}
			catch (Exception ex)
			{
				logger.error("Error initializing CreatePrimaryKeySeed: ", ex);
			}
		}
	}

	@Override
	public String encrypt(CryptType cryptType, String rawValue) throws Exception
	{
		if (CryptType.USER_PRIMARY.equals(cryptType) || CryptType.USER_SECONDARY.equals(cryptType))
		{
			logger.error("Crypt Type " + cryptType.name() + " Cannot  be used wih this method");
		}
		return encrypt(cryptType, rawValue, null);
	}

	public String decrypt(CryptType cryptType, String encryptedValue) throws Exception
	{
		return decrypt(cryptType, encryptedValue, (AuthUser) null);
	}

	@Override
	public String encrypt(CryptType cryptType, String rawValue, AuthUser user) throws Exception
	{
		if (Utils.isNull(rawValue))
		{
			return null;
		}

		switch (cryptType)
		{
			case SYSTEM_PRIMARY:
				return encryptUsingSystemPrimaryKey(rawValue);

			case SYSTEM_SECONDARY:
				return encryptUsingSystemSecondaryKey(rawValue);

			case USER_PRIMARY:
			case USER_SECONDARY:
				return encryptUsingUserKey(user, rawValue);

			default:
				throw new UnsupportedOperationException("Invalid CryptType: " + cryptType.name());
		}
	}

	@Override
	public boolean isEncryptedWithKey(CryptType cryptType, String encryptedValue)
	{
		switch (cryptType)
		{
			case SYSTEM_PRIMARY:
				return CryptType.SYSTEM_PRIMARY.matchesEncryptionVersions(encryptedValue);

			case SYSTEM_SECONDARY:
				return CryptType.SYSTEM_SECONDARY.matchesEncryptionVersions(encryptedValue);

			case USER_PRIMARY:
				return CryptType.USER_PRIMARY.matchesEncryptionVersions(encryptedValue);

			case USER_SECONDARY:
				return CryptType.USER_SECONDARY.matchesEncryptionVersions(encryptedValue);

			default:
				throw new UnsupportedOperationException(
						"Invalid CryptType provided: " + cryptType.name());
		}
	}

	/**
	 * If SYSTEM_PRIMARY version is 'V2' encrypt using AWS CMK, otherwise use keystore
	 *
	 * @param rawValue
	 * @return
	 * @throws Exception
	 */
	protected String encryptUsingSystemPrimaryKey(String rawValue) throws Exception
	{
		if (this.getKeyManager()
				.isSystmePrimaryKeyMigratedToAWS())
		{
			if (StringUtils.isEmpty(this.getKeyManager()
					.getSystemPrimaryAliasName()))
			{
				throw new SafePageException("systemPrimaryAliasName is null!");
			}
			String result = KMSServiceImpl.getInstance()
					.encryptUsingAWSKey(rawValue, this.getKeyManager()
							.getSystemPrimaryAliasName());
			if (StringUtils.isNoneEmpty(result))
			{
				return CryptType.SYSTEM_PRIMARY.getVersion() + result;
			}
		}
		return null;
	}

	protected String encryptUsingSystemSecondaryKey(String rawValue) throws Exception
	{
		KeyData systemKeyData = this.getKeyManager()
				.getDefaultSystemSecondaryKey();

		// Check if V4 feature flag is enabled for this System Secondary KeySeed
		String encryptionVersion = systemKeyData.getKeySeed()
				.getEncryptionVersion();
		// Default to V2 encryption if feature flag is null
		encryptionVersion = Utils.isNotNull(encryptionVersion) ? encryptionVersion
				: CryptType.SYSTEM_SECONDARY.getVersion();

		// V4 encryption uses GCM mode for encryption algorithm
		String transformation = "";
		if (CryptType.V4.equals(encryptionVersion))
		{
			transformation = KeyManager.ENCRYPTION_TRANSFORMATION_AES_GCM;
			encryptionVersion = encryptionVersion + MODE;
		}

		String result = encrypt(CryptType.SYSTEM_SECONDARY, rawValue, systemKeyData.getKey(),
				transformation);
		/*
		 * If SYSTEM_SECONDARY version is V2|V4, add version & keyseed name to the result
		 */
		if (Utils.isNotNull(result) && systemKeyData.getKeySeed() != null)
		{
			return encryptionVersion + systemKeyData.getKeySeed()
					.getName() + result;
		}
		return null;
	}

	protected String encryptUsingUserKey(AuthUser authUser, String rawValue) throws Exception
	{
		if (authUser == null || authUser.getUser() == null)
		{
			String errorMessage = new StringBuilder().append("Encryption using ")
					.append(CryptType.USER_PRIMARY)
					.append(" requires an AuthUser")
					.toString();
			throw new Exception(errorMessage);
		}
		if (!authUser.isPersonDelegate() && authUser.getId() == null)
		{
			logger.warn("{} requires AuthUser id, when AuthUser is not person delegate",
					CryptType.USER_PRIMARY);
		}
		JSONObject jsonResult = new JSONObject();
		jsonResult.put(SAFEPAGE_PAYLOAD, rawValue);
		jsonResult.put(SAFEPAGE_USER_ID, authUser.isPersonDelegate() ? authUser.getUser()
				.getId() : authUser.getId());

		KeyData userKeyData = getKeyManager().getDefaultUserKey(authUser);
		if (userKeyData == null || userKeyData.getKey() == null || userKeyData.getKeySeed() == null)
		{
			String errorMessage = "Failed to get " + CryptType.USER_PRIMARY + " keyData for ID="
					+ authUser.getId();
			throw new Exception(errorMessage);
		}

		// Check if V5 feature flag is enabled for this KeySeed
		UserPrimaryKey userPrimaryKey = UserPrimaryKeyContext.getUserPrimaryKey();
		String encryptionVersion = userKeyData.getKeySeed()
				.getEncryptionVersion();
		if (userPrimaryKey.isUseV3Version())
		{
			encryptionVersion = CryptType.V3;
		}

		// Default to V3 encryption if feature flag is null
		encryptionVersion = Utils.isNotNull(encryptionVersion) ? encryptionVersion
				: CryptType.USER_PRIMARY.getVersion();

		// V5 encryption uses GCM mode for encryption algorithm
		String transformation = null;
		if (CryptType.V5.equals(encryptionVersion))
		{
			transformation = KeyManager.ENCRYPTION_TRANSFORMATION_AES_GCM;
			encryptionVersion = encryptionVersion + MODE;
		}

		String result = encrypt(CryptType.USER_PRIMARY, jsonResult.toString(), userKeyData.getKey(),
				transformation);

		/*
		 * Add encryptionVersion & keyseed name to the result before returning it
		 */
		return encryptionVersion + userKeyData.getKeySeed()
				.getName() + result;
	}

	/**
	 * the passed encryptedValue should contain the leading version and short key name. this method
	 * will use these values to determine how to decrypt the encrypted value
	 */
	@Override
	@SuppressWarnings("deprecation")
	public String decrypt(CryptType cryptType, String encryptedValue, AuthUser user)
			throws Exception
	{
		String result = null;

		if (Utils.isNotNull(encryptedValue))
		{
			switch (cryptType)
			{
				case SYSTEM_PRIMARY:
					result = decryptUsingSystemPrimaryKey(encryptedValue);
					break;

				case SYSTEM_SECONDARY:
					result = decryptUsingSystemSecondaryKey(encryptedValue);
					break;

				case USER_PRIMARY:
				case USER_SECONDARY:
					result = decryptUsingUserKey(user, encryptedValue);
					break;
				default:
					throw new UnsupportedOperationException(
							"Invalid CryptType: " + cryptType.name());
			}
		}
		return result;
	}

	/**
	 * @param encryptedValue
	 * @return
	 * @throws Exception
	 */
	protected String decryptUsingSystemPrimaryKey(String encryptedValue) throws Exception
	{
		if (StringUtils.isEmpty(encryptedValue))
		{
			return null;
		}
		try
		{
			/*
			 * Data encrypted with system primary keys are formatted as [version][encrypted data];
			 * e.g. V1encrypteddata
			 */
			String version = CryptType.getVersionFromEncryptedData(encryptedValue);
			if (StringUtils.isNotEmpty(version))
			{
				encryptedValue = encryptedValue.substring(CryptType.SEED_VERSION_LENGTH);
				// System Primary key in AWS KMS will be version V2
				if (CryptType.V2.equals(version))
				{
					return KMSServiceImpl.getInstance()
							.decryptUsingAWSKey(encryptedValue);
				}
			}
		}
		catch (Exception anException)
		{
			logger.warn("Failed to decrypt because: ", anException);
		}
		return null;
	}
