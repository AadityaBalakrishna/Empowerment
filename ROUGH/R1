try
		{
			if (resultIsCollection)
			{
				// get all the newly fetched data
				Collection<Object> collectionResultForMissed = (Collection<Object>) resultForMissed;

				// check if something from the result has to be used as part of the key.
				if (Utils.isNotNull(resultKeyField)
						|| (resultKeyFields != null && resultKeyFields.length > 0))
				{
					Collection<Object> mergedResult = getCollectionResult(listKeyArg, keyValueMap,
							collectionResult);

					// if nothing new was found for the missed keys, just return the existing
					// collection
					if (collectionResultForMissed == null || collectionResultForMissed.isEmpty())
						return mergedResult;

					List<Object> keyFieldValues = new ArrayList<Object>();

					for (Object resultItemForMissed : collectionResultForMissed)
					{
						if (resultItemForMissed == null)
							continue;

						keyFieldValues.clear();
						if ((resultKeyFields != null && resultKeyFields.length > 0))
						{
							// if key is to be derived from result, then get the field from result
							// using reflection and create the cache key
							for (int i = 0; i < resultKeyFields.length; i++)
							{
								Object keyFieldValue = PropertyAccessorFactory
										.forBeanPropertyAccess(resultItemForMissed)
										.getPropertyValue(resultKeyFields[i]);
								keyFieldValues.add(cacheKeyProvider.getKeyField(keyFieldValue));
							}
						}
						else
						{// is only one is property is given use that value for key directly
							Object keyFieldValue = PropertyAccessorFactory
									.forBeanPropertyAccess(resultItemForMissed)
									.getPropertyValue(resultKeyField);

							if (keyFieldValue != null)
							{
								keyFieldValues.add(cacheKeyProvider.getKeyField(keyFieldValue));
							}
						}

						// genearteKey and add the item fetched from db.
						if (keyFieldValues.size() > 0)
						{
							String cacheKey = CacheUtils.generateKey(cacheName, keyPrefix,
									keyFieldValues, otherKeyArgs);
							getRedisson(redisType).getBucket(cacheKey)
									.set(resultItemForMissed, ttlSeconds, TimeUnit.SECONDS);
							// Cache Store Metric
							publishCacheMetrics(pjp, "store");
						}
						// add found item to resultant collection from cache+db that has to be
						// returned
						mergedResult.add(resultItemForMissed);
					}

					return mergedResult;
				}

resultKeyField is null, so data store is getting skipped, any way to avoid this, you have the fullPcapMultiCacheableAdvice code right to refer to what i am saying?
