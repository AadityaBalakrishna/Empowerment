package com.personalcapital.cache.aop;

import static org.mockito.Mockito.*;

import java.util.*;

import org.aspectj.lang.ProceedingJoinPoint;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;

import com.personalcapital.cache.annotation.PcapMultiCacheable;
import com.personalcapital.cache.annotation.RedisType;
import com.personalcapital.cache.aop.support.CacheKeyProvider;
import com.personalcapital.cache.utils.CacheUtils;

import io.micrometer.core.instrument.Metrics;
import io.micrometer.core.instrument.simple.SimpleMeterRegistry;

@ExtendWith(MockitoExtension.class)
public class PcapMultiCacheableAdviceMetricsTest {

    @InjectMocks
    private PcapMultiCacheableAdvice cacheAdvice;

    @Mock
    private ProceedingJoinPoint pjp;

    @Mock
    private PcapMultiCacheable pcapMultiCacheable;

    @Mock
    private CacheKeyProvider cacheKeyProvider;

    @Mock
    private RedisType redisType;

    @BeforeEach
    void setUp() {
        Metrics.addRegistry(new SimpleMeterRegistry()); // Initialize test metrics
    }

    /** ✅ **Test Case 1: Cache Failure (Cache Read Error, Should Still Call DB)** */
    @Test
    void testCacheFailure() throws Throwable {
        when(pcapMultiCacheable.value()).thenReturn("testCache");
        when(pjp.getTarget()).thenReturn(this);
        when(pjp.getSignature().getName()).thenReturn("testCacheFailureMethod");
        when(pjp.getArgs()).thenReturn(new Object[]{List.of("key1")});

        // Simulate cache retrieval failure
        doThrow(new RuntimeException("Cache failure")).when(cacheAdvice).getRedisson(any());

        Object result = cacheAdvice.doMultiCacheable(pjp, pcapMultiCacheable);

        verify(pjp, times(1)).proceed(); // Should proceed to DB
        assert result != null;

        // Verify Cache Failure Metric
        assertEquals(1, Metrics.counter("pcap.cache.failure").count(), 
                     "Cache failure metric should be incremented");
    }

    /** ✅ **Test Case 2: Eviction Failure (Cache Eviction Fails, Should Still Continue)** */
    @Test
    void testEvictionFailure() throws Throwable {
        when(pcapMultiCacheable.value()).thenReturn("testCache");
        when(pjp.getTarget()).thenReturn(this);
        when(pjp.getSignature().getName()).thenReturn("testEvictionFailureMethod");
        when(pjp.getArgs()).thenReturn(new Object[]{List.of("key1")});

        // Simulate eviction failure
        doThrow(new RuntimeException("Eviction failure")).when(cacheAdvice).evictFromRedis(any(), any());

        Object result = cacheAdvice.doMultiCacheable(pjp, pcapMultiCacheable);

        verify(pjp, times(1)).proceed(); // Should still call DB
        assert result != null;

        // Verify Eviction Failure Metric
        assertEquals(1, Metrics.counter("pcap.cache.eviction.failure").count(), 
                     "Eviction failure metric should be incremented");
    }

    /** ✅ **Test Case 3: Data Mismatch Warning (Cache Order Issue, Should Log Warning)** */
    @Test
    void testDataMismatchWarning() throws Throwable {
        when(pcapMultiCacheable.value()).thenReturn("testCache");
        when(pjp.getTarget()).thenReturn(this);
        when(pjp.getSignature().getName()).thenReturn("testDataMismatchMethod");
        when(pjp.getArgs()).thenReturn(new Object[]{List.of("key1", "key2")});

        List<Object> cacheData = Arrays.asList("item1", "item2");
        List<Object> dbData = Collections.singletonList("item1"); // Missing one item

        // Simulate a mismatch between cache and DB data
        when(cacheAdvice.getCollectionResult(any(), any(), any())).thenReturn(dbData);

        Object result = cacheAdvice.doMultiCacheable(pjp, pcapMultiCacheable);

        verify(pjp, times(1)).proceed(); // Should still execute
        assert result != null;

        // Verify Data Mismatch Metric
        assertEquals(1, Metrics.counter("pcap.cache.data.mismatch").count(), 
                     "Data mismatch metric should be incremented");
    }
}