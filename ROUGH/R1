public class IPClusteringRuleTest {
    private IPClusteringRule iPClusteringRule;
    private CacheManager cacheManager;
    private static Cache securityCache;
    private IPManager iPManager;  // <-- made this a class field

    private UserDao userDao;
    private UserEventManager userEventManager;
    private UserFeatureTypeUtils userFeatureTypeUtils;

    private static final String TEST_IP_ADDRESS = "235.156.38.71";

    @BeforeEach
    public void setUp() {
        iPClusteringRule = new IPClusteringRule();

        userDao = mock(UserDao.class);
        userEventManager = mock(UserEventManager.class);
        userFeatureTypeUtils = mock(UserFeatureTypeUtils.class);
        iPManager = mock(IPManager.class); // <-- moved here

        cacheManager = mock(CacheManager.class);
        securityCache = mock(Cache.class);
        when(cacheManager.getCache("security")).thenReturn(securityCache);

        UserSuspicionUtils userSuspicionUtils = mock(UserSuspicionUtils.class);
        when(userSuspicionUtils.isSetToNonSuspicious(any())).thenReturn(false);

        // Inject mocks
        ReflectionTestUtils.setField(iPClusteringRule, "userDao", userDao);
        ReflectionTestUtils.setField(iPClusteringRule, "userEventManager", userEventManager);
        ReflectionTestUtils.setField(iPClusteringRule, "userFeatureTypeUtils", userFeatureTypeUtils);
        ReflectionTestUtils.setField(iPClusteringRule, "iPManager", iPManager);
        ReflectionTestUtils.setField(iPClusteringRule, "userSuspicionUtils", userSuspicionUtils);

        Mockito.doNothing().when(userEventManager).addUserEvent(any(), any(), any());

        setupUpdateIsSuspicious();
    }

    private void setupUpdateIsSuspicious() {
        when(userDao.updateIsSuspicious(any(User.class), any(Boolean.class), any(SuspicionReasonType.class)))
            .thenAnswer(invocation -> {
                User user = invocation.getArgument(0);
                ((UserImpl) user).setSuspicious(invocation.getArgument(1));
                ((UserImpl) user).setSuspicionReason(invocation.getArgument(2));
                return user;
            });
    }

    @Test
    public void testValidate() throws SafePageException {
        UserImpl user = new UserImpl();
        user.setId(1L);

        HttpServletRequest request = mock(org.springframework.mock.web.MockHttpServletRequest.class);
        RequestContext rc = ContextManager.getRequestContext(request, mock(org.springframework.mock.web.MockHttpServletResponse.class), true);
        rc.setAttribute("USER_ATTRIBUTE", user);

        when(request.getRemoteAddr()).thenReturn(TEST_IP_ADDRESS);
        when(request.getHeader("user-agent")).thenReturn("Mozilla/5.0");
        when(request.getMethod()).thenReturn("POST");

        // Case 1: IP not flagged
        when(iPManager.getIPAddress(TEST_IP_ADDRESS)).thenReturn(null);
        boolean validated = iPClusteringRule.validate();
        Assertions.assertTrue(validated);

        // Case 2: IP flagged but whitelisted
        FlaggedIpAddress ip = new FlaggedIpAddressImpl();
        ip.setIpAddrString(TEST_IP_ADDRESS);
        ip.setSuspicious(true);
        ip.setWhiteListed(true);
        when(iPManager.getIPAddress(TEST_IP_ADDRESS)).thenReturn(ip);

        user.setSuspicious(false);
        validated = iPClusteringRule.validate();
        Assertions.assertTrue(validated);

        // Case 3: IP flagged and not whitelisted
        ip.setWhiteListed(false);
        when(iPManager.getIPAddress(TEST_IP_ADDRESS)).thenReturn(ip);

        validated = iPClusteringRule.validate();
        Assertions.assertFalse(validated);

        // Case 4: Using securityCache instead of DB
        user.setSuspicious(false);
        securityCache.put("ip:" + TEST_IP_ADDRESS, ip);
        validated = iPClusteringRule.validate();
        Assertions.assertFalse(validated);  // Since it's not whitelisted
    }

    @AfterAll
    public static void clearUp() {
        if (securityCache != null) {
            securityCache.evict("ip:" + TEST_IP_ADDRESS);
        }
    }
}
