package com.personalcapital.cache.aop;

import com.personalcapital.cache.annotation.RedisType;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.junit.jupiter.MockitoExtension;
import org.redisson.api.RedissonClient;
import org.redisson.api.RKeys;
import org.redisson.api.RBucket;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
public class PcapMultiCacheableAdviceTest {

	@Mock
	private RedissonClient redissonClient;  // Mock RedissonClient

	@Mock
	private RKeys rKeys;  // Mock for key deletion

	@Mock
	private RBucket<String> rBucket; // Mock for key-value interactions

	private CacheAdviceCommons cacheAdviceCommons;

	@BeforeEach
	void setUp() {
		MockitoAnnotations.openMocks(this);
		redissonClient = mock(RedissonClient.class);
		RBucket<Object> mockBucket;
		mockBucket - mock(RBucket.class);
		when(redissonClient.getBucket(anyString())).thenReturn(mockBucket);

		// Mock RedissonClient to return our mock RKeys
		when(redissonClient.getKeys()).thenReturn(rKeys);
		when(redissonClient.getBucket(anyString())).thenReturn(rBucket);

		// Create a real instance of CacheAdviceCommons but override Redisson
		cacheAdviceCommons = spy(new CacheAdviceCommons());

		// Override getRedisson() to return our mocked RedissonClient
		doReturn(redissonClient).when(cacheAdviceCommons).getRedisson(any());
	}

	@Test
	void testEvictSingleKey_Success() {
		// Simulate successful deletion
		when(rBucket.delete()).thenReturn(true);

		boolean result = cacheAdviceCommons.evictFromRedis(RedisType.GEN, "testKey");

		assertTrue(result, "Eviction should be successful");
		verify(rBucket, times(1)).delete();
	}

	@Test
	void testEvictSingleKey_Failure() {
		// Simulate failed deletion
		when(rBucket.delete()).thenThrow(new RuntimeException("Redis failure"));

		boolean result = cacheAdviceCommons.evictFromRedis(RedisType.GEN, "testKey");

		assertFalse(result, "Eviction should fail and return false");
		verify(rBucket, times(1)).delete();
	}

	@Test
	void testEvictMultipleKeys_Success() {
		// Simulate successful deletion for multiple keys
		when(rKeys.delete(any(String[].class))).thenReturn(2L); // Assume 2 keys deleted

		List<String> keys = Arrays.asList("key1", "key2");
		boolean result = cacheAdviceCommons.evictFromRedis(RedisType.GEN, keys);

		assertTrue(result, "Eviction should be successful");
		verify(rKeys, times(1)).delete(any(String[].class));
	}

	@Test
	void testEvictMultipleKeys_EmptyList() {
		boolean result = cacheAdviceCommons.evictFromRedis(RedisType.GEN, Collections.emptyList());

		assertTrue(result, "Eviction should be skipped for an empty list");
		verify(rKeys, never()).delete(any(String[].class));
	}

	@Test
	void testEvictMultipleKeys_Failure() {
		// Simulate failure scenario
		when(rKeys.delete(any(String[].class))).thenThrow(new RuntimeException("Redis error"));

		List<String> keys = Arrays.asList("key1", "key2");
		boolean result = cacheAdviceCommons.evictFromRedis(RedisType.GEN, keys);

		assertFalse(result, "Eviction should fail and return false");
		verify(rKeys, times(1)).delete(any(String[].class));
	}
}
