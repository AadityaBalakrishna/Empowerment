@Service
public class EpwKmsServiceImpl implements EpwKmsService{

	private static final PcapLogger logger = PcapLoggerFactory
			.getPcapLogger(EpwKmsServiceImpl.class);
	private static final Charset charset = StandardCharsets.UTF_8;

	private final KmsClient kmsClient;

	public EpwKmsServiceImpl(KmsClient kmsClient) {
		this.kmsClient = kmsClient;
	}

	@Override
	public EncryptResponseDTO encrypt(EncryptRequestDTO request) throws SafePageException{
		if (StringUtils.isEmpty(request.getPlaintext())){
			throw new SafePageException(SafePageErrorType.INVALID_INPUT, "plainText is required!");
		}
		if (StringUtils.isEmpty(request.getKeyId())){
			throw new SafePageException(SafePageErrorType.INVALID_INPUT, "keyId is required!");
		}
		try{
			EncryptRequest encryptRequest = EncryptRequest.builder()
					.keyId(request.getKeyId())
					.plaintext(SdkBytes.fromByteBuffer(getByteBuffer(request.getPlaintext())))
					.build();

			long start = System.currentTimeMillis();
			EncryptResponse result = kmsClient.encrypt(encryptRequest);
			long end = System.currentTimeMillis();
			logger.info("encryptData took {} ", (end - start));

			if (result == null || result.ciphertextBlob() == null) {
				throw new SafePageException(SafePageErrorType.INTERNAL_ERROR, "Encryption failed: result is null");
			}

			String encoded = Utils.encodeBase64(result.ciphertextBlob().asByteBuffer().array());
			return new EncryptResponseDTO(encoded);
		}
		catch (DisabledException de)
		{
			logger.error(
					"Failed to encryptUsingAWSKey(DisabledException), plainText:{}, keyId:{}, due to:{}",
					request.getPlaintext(), request.getKeyId(), ExceptionUtils.getMessage(de), de);
		}
		catch (KeyUnavailableException kue)
		{
			logger.error(
					"Failed to encryptUsingAWSKey(KeyUnavailableException), plainText:{}, keyId:{}, due to:{}",
					request.getPlaintext(), request.getKeyId(), ExceptionUtils.getMessage(kue),
					kue);
		}
		catch (Exception ex)
		{
			logger.error("Failed to encryptUsingAWSKey, plainText:{}, keyId:{}, due to:{}",
					request.getPlaintext(), request.getKeyId(), ExceptionUtils.getMessage(ex), ex);
		}
		return null;
	}

	@Override
	public DecryptResponseDTO decrypt(DecryptRequestDTO request) throws SafePageException
	{
		if (StringUtils.isEmpty(request.getCiphertext()))
		{
			throw new SafePageException(SafePageErrorType.INVALID_INPUT, "cipherText is required!");
		}
		try
		{
			byte[] decodedCipherText = Utils.decodeBase64(request.getCiphertext());
			DecryptRequest decryptRequest = DecryptRequest.builder()
					.ciphertextBlob(SdkBytes.fromByteArray(decodedCipherText))
					.build();

			long start = System.currentTimeMillis();
			DecryptResponse result = kmsClient.decrypt(decryptRequest);
			long end = System.currentTimeMillis();
			logger.info("decryptData took {} ", (end - start));
			String decrypted = getString(result.plaintext().asByteBuffer());
			return new DecryptResponseDTO(decrypted);
		}
		catch (KeyUnavailableException kue)
		{
			// The request was rejected because the specified CMK was not available. The request can
			// be retried.
			logger.error(
					"Failed to decryptUsingAWSKey(KeyUnavailableException), cipherText:{}, due to:{}",
					request.getCiphertext(), ExceptionUtils.getMessage(kue), kue);
		}
		catch (InvalidCiphertextException ice)
		{
			// The request was rejected because the specified ciphertext, or additional
			// authenticated data incorporated
			// into the ciphertext, such as the encryption context, is corrupted, missing, or
			// otherwise invalid.
			logger.error(
					"Failed to decryptUsingAWSKey(InvalidCiphertextException), cipherText:{}, due to:{}",
					request.getCiphertext(), ExceptionUtils.getMessage(ice), ice);
		}
		catch (DisabledException de)
		{
			logger.error(
					"Failed to decryptUsingAWSKey(DisabledException), cipherText:{}, due to:{}",
					request.getCiphertext(), ExceptionUtils.getMessage(de), de);
		}
		catch (Exception ex)
		{
			logger.error("Failed to decryptUsingAWSKey, cipherText:{}, due to:{}",
					request.getCiphertext(), ExceptionUtils.getMessage(ex), ex);
		}
		return null;
	}

	private ByteBuffer getByteBuffer(String string) {
		return ByteBuffer.wrap(string.getBytes(charset));
	}

	public static String getString(ByteBuffer byteBuffer) {
		byte[] byteArray = new byte[byteBuffer.remaining()];
		byteBuffer.get(byteArray);
		return charset.decode(byteBuffer).toString();
	}

	@Override
	@Deprecated
	public DescribeKeyResponseDTO describeKey(String keyId) throws SafePageException{
		try{
			DescribeKeyResponse response = kmsClient.describeKey(DescribeKeyRequest.builder().keyId(keyId).build());
			return new DescribeKeyResponseDTO(
					response.keyMetadata().keyId(),
					response.keyMetadata().arn(),
					response.keyMetadata().keyStateAsString(),
					response.keyMetadata().enabled()
			);
		}
		catch (Exception ex){
			logger.error("Failed to describeKey, keyId:{}, due to:{}", keyId, ExceptionUtils.getMessage(ex), ex);
			return null;
		}
	}

	@Override
	@Deprecated
	public ListAliasesResponseDTO listAliases() throws SafePageException {
		try {
			ListAliasesResponse response = kmsClient.listAliases(ListAliasesRequest.builder().limit(100).build());
			List<ListAliasesResponseDTO.AliasEntry> aliasEntries = response.aliases().stream()
					.map(alias -> new ListAliasesResponseDTO.AliasEntry(
							alias.aliasName(),
							alias.targetKeyId()))
					.toList();
			return new ListAliasesResponseDTO(aliasEntries);
		} catch (Exception ex) {
			logger.error("Failed to listAliases, due to:{}", ExceptionUtils.getMessage(ex), ex);
			return null;
		}
	}
}
