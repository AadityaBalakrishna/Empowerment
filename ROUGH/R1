@Test
void testExceptionTriggersFailureMetric() throws Throwable {
    ProceedingJoinPoint pjp = mockProceedingJoinPoint();
    PcapMultiCacheable annotation = mockPcapMultiCacheable();

    // ✅ Do NOT use spy(cacheAdvice) directly
    PcapMultiCacheableAdvice spyAdvice = spy(new PcapMultiCacheableAdvice());

    // ✅ Use `doAnswer` instead of `doThrow`
    doAnswer(invocation -> { throw new RuntimeException("Simulated exception"); })
            .when(pjp).proceed();

    try (MockedStatic<Metrics> mockedMetrics = mockStatic(Metrics.class)) {
        Counter mockCounter = mock(Counter.class);
        mockedMetrics.when(() -> Metrics.counter(anyString(), any(String[].class)))
                     .thenReturn(mockCounter);

        try {
            spyAdvice.doMultiCacheable(pjp, annotation);
        } catch (Exception ignored) {
            // Expected exception
        }

        // ✅ Verify that publishCacheMetrics was called with "failure"
        verify(spyAdvice, times(1)).publishCacheMetrics(eq(pjp), eq("failure"));

        // ✅ Capture the actual metric triggered
        ArgumentCaptor<String> metricNameCaptor = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<String[]> tagsCaptor = ArgumentCaptor.forClass(String[].class);

        mockedMetrics.verify(() -> Metrics.counter(metricNameCaptor.capture(), tagsCaptor.capture()), times(1));
        verify(mockCounter, times(1)).increment();

        // ✅ Ensure correct metric tags
        List<String> capturedTags = Arrays.asList(tagsCaptor.getValue());
        assertTrue(capturedTags.contains("outcome"), "Tags should contain 'outcome'");
        assertTrue(capturedTags.contains("failure"), "Tags should contain 'failure'");
    }
}
