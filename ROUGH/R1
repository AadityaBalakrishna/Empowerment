package com.personalcapital.cache.aop;

import com.personalcapital.cache.annotation.PcapMultiCacheable;
import com.personalcapital.cache.annotation.RedisType;
import com.personalcapital.cache.aop.support.CacheAdviceHelper;
import com.personalcapital.cache.aop.support.CacheKeyProvider;
import com.personalcapital.cache.utils.CacheConstants;
import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.Metrics;
import io.micrometer.core.instrument.simple.SimpleMeterRegistry;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.Signature;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.*;
import org.redisson.api.RBucket;
import org.redisson.api.RedissonClient;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.cache.CacheManager;
import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;

import java.lang.reflect.Method;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

@SpringJUnitConfig(locations = { "classpath:cachePushAdviceTest-Context.xml" })
public class PcapMultiCacheableAdviceTest {

    @InjectMocks
    @Spy
    @Autowired
    private PcapMultiCacheableAdvice cacheAdvice;

    private SimpleMeterRegistry meterRegistry;
    private PcapMultiCacheable mockAnnotation;

    @Autowired
    @Qualifier(CacheConstants.REDISSON_REGULAR)
    private RedissonClient redissonClient;

    @Autowired
    @Qualifier(CacheConstants.REDIS_CACHE_MANAGER_REGULAR)
    private CacheManager cacheManager;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);

        meterRegistry = new SimpleMeterRegistry();
        Metrics.addRegistry(meterRegistry);

        redissonClient = mock(RedissonClient.class);
        RBucket<Object> mockBucket = mock(RBucket.class);
        when(redissonClient.getBucket(anyString())).thenReturn(mockBucket);

        mockAnnotation = mock(PcapMultiCacheable.class);
        when(mockAnnotation.value()).thenReturn("testCache");
        when(mockAnnotation.keys()).thenReturn(new int[]{0});
        when(mockAnnotation.keyPrefix()).thenReturn("prefix");
        when(mockAnnotation.redisType()).thenReturn(RedisType.DEFAULT);
        when(mockAnnotation.keyProvider()).thenAnswer(invocation -> DummyCacheKeyProvider.class);

        try (MockedStatic<CacheAdviceHelper> mockedStatic = mockStatic(CacheAdviceHelper.class)) {
            Method mockMethod = DummyClass.class.getMethod("dummyMethod");
            mockedStatic.when(() -> CacheAdviceHelper.getMethod(any(ProceedingJoinPoint.class))).thenReturn(mockMethod);
        } catch (NoSuchMethodException e) {
            throw new RuntimeException("Failed to mock getMethod", e);
        }
    }

    public static class DummyClass {
        public void dummyMethod() {}
    }

    /**
     * ✅ Test Cache Hit (should record "hit")
     */
    @Test
    void testCacheHitMetric() throws Throwable {
        ProceedingJoinPoint pjp = mockProceedingJoinPoint();

        try (MockedStatic<Metrics> mockedMetrics = Mockito.mockStatic(Metrics.class)) {
            Counter mockCounter = mock(Counter.class);
            mockedMetrics.when(() -> Metrics.counter(anyString(), any(String[].class)))
                    .thenReturn(mockCounter);

            // Simulate cache hit
            when(redissonClient.getBucket(anyString()).get()).thenReturn("cachedValue");

            Object result = cacheAdvice.doMultiCacheable(pjp, mockAnnotation);

            assertNotNull(result);
            assertEquals("cachedValue", result);

            ArgumentCaptor<String> outcomeCaptor = ArgumentCaptor.forClass(String.class);
            mockedMetrics.verify(() -> Metrics.counter(anyString(), any(), any(), any(), any(), "outcome", outcomeCaptor.capture()), atLeastOnce());

            System.out.println("Captured Metrics: " + outcomeCaptor.getAllValues());
            assertTrue(outcomeCaptor.getAllValues().contains("hit"), "Expected 'hit' metric but got: " + outcomeCaptor.getAllValues());

            verify(mockCounter, atLeastOnce()).increment();
        }
    }

    /**
     * ✅ Test Cache Miss (should record "miss")
     */
    @Test
    void testCacheMissMetric() throws Throwable {
        ProceedingJoinPoint pjp = mockProceedingJoinPoint();

        try (MockedStatic<Metrics> mockedMetrics = Mockito.mockStatic(Metrics.class)) {
            Counter mockCounter = mock(Counter.class);
            mockedMetrics.when(() -> Metrics.counter(anyString(), any(String[].class)))
                    .thenReturn(mockCounter);

            // Simulate cache miss
            when(redissonClient.getBucket(anyString()).get()).thenReturn(null);

            Object result = cacheAdvice.doMultiCacheable(pjp, mockAnnotation);

            assertNotNull(result);
            assertEquals("dbFetchedValue", result);

            ArgumentCaptor<String> outcomeCaptor = ArgumentCaptor.forClass(String.class);
            mockedMetrics.verify(() -> Metrics.counter(anyString(), any(), any(), any(), any(), "outcome", outcomeCaptor.capture()), atLeastOnce());

            System.out.println("Captured Metrics: " + outcomeCaptor.getAllValues());
            assertTrue(outcomeCaptor.getAllValues().contains("miss"), "Expected 'miss' metric but got: " + outcomeCaptor.getAllValues());

            verify(mockCounter, atLeastOnce()).increment();
        }
    }

    /**
     * ✅ Test Cache Failure (should record "failure")
     */
    @Test
    void testCacheFailureMetric() throws Throwable {
        ProceedingJoinPoint pjp = mockProceedingJoinPoint();

        try (MockedStatic<Metrics> mockedMetrics = Mockito.mockStatic(Metrics.class)) {
            Counter mockCounter = mock(Counter.class);
            mockedMetrics.when(() -> Metrics.counter(anyString(), any(String[].class)))
                    .thenReturn(mockCounter);

            // Simulate an exception
            when(redissonClient.getBucket(anyString()).get()).thenThrow(new RuntimeException("Simulated Cache Failure"));

            Object result = cacheAdvice.doMultiCacheable(pjp, mockAnnotation);

            assertNotNull(result);

            ArgumentCaptor<String> outcomeCaptor = ArgumentCaptor.forClass(String.class);
            mockedMetrics.verify(() -> Metrics.counter(anyString(), any(), any(), any(), any(), "outcome", outcomeCaptor.capture()), atLeastOnce());

            System.out.println("Captured Metrics: " + outcomeCaptor.getAllValues());
            assertTrue(outcomeCaptor.getAllValues().contains("failure"), "Expected 'failure' metric but got: " + outcomeCaptor.getAllValues());

            verify(mockCounter, atLeastOnce()).increment();
        }
    }
    // ✅ Test "store" metric (when value is stored in cache)
    @Test
    void testCacheStoreMetric() throws Throwable {
        ProceedingJoinPoint pjp = mockProceedingJoinPoint();

        try (MockedStatic<Metrics> mockedMetrics = Mockito.mockStatic(Metrics.class)) {
            Counter mockCounter = mock(Counter.class);
            mockedMetrics.when(() -> Metrics.counter(anyString(), any(String[].class)))
                    .thenReturn(mockCounter);

            // Simulate a cache miss, but allow storing the value
            when(redissonClient.getBucket(anyString()).get()).thenReturn(null);
            when(redissonClient.getBucket(anyString()).set(any(), anyLong(), any())).thenReturn(null);

            Object result = cacheAdvice.doMultiCacheable(pjp, mockAnnotation);

            assertNotNull(result);

            ArgumentCaptor<String> outcomeCaptor = ArgumentCaptor.forClass(String.class);
            mockedMetrics.verify(() -> Metrics.counter(anyString(), any(), any(), any(), any(), "outcome", outcomeCaptor.capture()), atLeastOnce());

            System.out.println("Captured Metrics: " + outcomeCaptor.getAllValues());
            assertTrue(outcomeCaptor.getAllValues().contains("store"), "Expected 'store' metric but got: " + outcomeCaptor.getAllValues());

            verify(mockCounter, atLeastOnce()).increment();
        }
    }

    // ✅ Test "eviction_failure" metric (when cache eviction fails)
    @Test
    void testCacheEvictionFailureMetric() throws Throwable {
        ProceedingJoinPoint pjp = mockProceedingJoinPoint();

        try (MockedStatic<Metrics> mockedMetrics = Mockito.mockStatic(Metrics.class)) {
            Counter mockCounter = mock(Counter.class);
            mockedMetrics.when(() -> Metrics.counter(anyString(), any(String[].class)))
                    .thenReturn(mockCounter);

            // Simulate an exception when trying to evict from the cache
            doThrow(new RuntimeException("Simulated Eviction Failure")).when(redissonClient).getBucket(anyString());

            Object result = cacheAdvice.doMultiCacheable(pjp, mockAnnotation);

            assertNotNull(result);

            ArgumentCaptor<String> outcomeCaptor = ArgumentCaptor.forClass(String.class);
            mockedMetrics.verify(() -> Metrics.counter(anyString(), any(), any(), any(), any(), "outcome", outcomeCaptor.capture()), atLeastOnce());

            System.out.println("Captured Metrics: " + outcomeCaptor.getAllValues());
            assertTrue(outcomeCaptor.getAllValues().contains("eviction_failure"), "Expected 'eviction_failure' metric but got: " + outcomeCaptor.getAllValues());

            verify(mockCounter, atLeastOnce()).increment();
        }
    }

    // ✅ Test "data_mismatch" metric (when DB results do not match requested keys)
    @Test
    void testDataMismatchMetric() throws Throwable {
        ProceedingJoinPoint pjp = mockProceedingJoinPoint();

        try (MockedStatic<Metrics> mockedMetrics = Mockito.mockStatic(Metrics.class)) {
            Counter mockCounter = mock(Counter.class);
            mockedMetrics.when(() -> Metrics.counter(anyString(), any(String[].class)))
                    .thenReturn(mockCounter);

            // Simulate a cache miss but return fewer results from DB
            when(redissonClient.getBucket(anyString()).get()).thenReturn(null);
            when(pjp.proceed()).thenReturn(Collections.singletonList("fewerResults")); // DB returns fewer items

            Object result = cacheAdvice.doMultiCacheable(pjp, mockAnnotation);

            assertNotNull(result);

            ArgumentCaptor<String> outcomeCaptor = ArgumentCaptor.forClass(String.class);
            mockedMetrics.verify(() -> Metrics.counter(anyString(), any(), any(), any(), any(), "outcome", outcomeCaptor.capture()), atLeastOnce());

            System.out.println("Captured Metrics: " + outcomeCaptor.getAllValues());
            assertTrue(outcomeCaptor.getAllValues().contains("data_mismatch"), "Expected 'data_mismatch' metric but got: " + outcomeCaptor.getAllValues());

            verify(mockCounter, atLeastOnce()).increment();
        }
    }
    private ProceedingJoinPoint mockProceedingJoinPoint() throws Throwable {
        ProceedingJoinPoint pjp = mock(ProceedingJoinPoint.class);
        Signature mockSignature = mock(Signature.class);
        when(pjp.getTarget()).thenReturn(cacheAdvice);
        when(pjp.getSignature()).thenReturn(mockSignature);
        when(mockSignature.getName()).thenReturn("testMethod");
        when(pjp.getArgs()).thenReturn(new Object[]{ Collections.singletonList("key1") });
        when(pjp.proceed()).thenReturn("dbFetchedValue");
        return pjp;
    }

    public static class DummyCacheKeyProvider implements CacheKeyProvider {
        @Override
        public Object getKeyField(Object value) {
            return value != null ? value.toString() : "null";
        }
    }
}
