
	/**
	 * Redis key for each securityId: "quote:Symbol:<securityId>" ttl = 600 sec = 10 min
	 */
	@Override
	@PcapMultiCacheable(value = "quote", keyProvider = QuoteCacheKeyProvider.class)
	public Map<SecurityId, Quote> getQuotes(List<SecurityId> securityIds)
	{
		Map<SecurityId, Quote> results = new HashMap<SecurityId, Quote>();

		List<SecurityId> pcapIndexList = new ArrayList<SecurityId>();
		List<SecurityId> securityIdListExcludingPCAPIndex = new ArrayList<SecurityId>();

		for (SecurityId securityId : securityIds)
		{
			if (securityId == null)
				continue;

			if (Utils.isNotNull(securityId.getSymbol())
					&& QuoteService.PCAP_CUSTOM_INDICES_MAP.containsKey(securityId.getSymbol()))
			{
				pcapIndexList.add(securityId);
			}
			else if (CryptoCurrencyUtils.isCryptoHolding(securityId.getSymbol()))
			{
				log(securityId, null, true, "quotes");
				if (!cryptoCacheUtils.isCryptoSymbolSupported(securityId))
				{
					log(securityId, "getQuotes");
					continue;
				}
				Quote quote = this.cryptoCompareQuoteService.getQuote(securityId);
				log(securityId, null, false, "quotes");
				if (quote != null)
				{
					results.put(securityId, quote);
				}
			}
			else
			{
				Quote quote = getLastClosingQuoteIfValidAndMarketClosed(securityId);
				if (quote != null)
				{
					results.put(securityId, quote);
					continue;
				}
				securityIdListExcludingPCAPIndex.add(securityId);
			}
		}

		Map<SecurityId, Quote> pcapIndexResults = null;
		if (!pcapIndexList.isEmpty())
			pcapIndexResults = this.getPCAPIndexQuotes(pcapIndexList, null);
		Map<SecurityId, Quote> resultsExcludingPCAPIndex = null;
		if (!securityIdListExcludingPCAPIndex.isEmpty())
			resultsExcludingPCAPIndex = backingQuoteService
					.getQuotes(securityIdListExcludingPCAPIndex);

		if (pcapIndexResults != null)
			results.putAll(pcapIndexResults);

		if (resultsExcludingPCAPIndex != null)
			results.putAll(resultsExcludingPCAPIndex);

		return results;
	}

