package com.empower.crm.core.engine.chain;

import com.empower.crm.core.engine.factory.WorkflowStepProcessorFactory;
import com.empower.crm.core.engine.processor.WorkflowStepProcessor;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.test.util.ReflectionTestUtils;

import java.util.*;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

/**
 * Unit tests for WorkflowChainBuilder.
 */
@ExtendWith(MockitoExtension.class)
class WorkflowChainBuilderTest
{

	@Mock
	private WorkflowStepProcessorFactory processorFactory;

	@Mock
	private WorkflowStepProcessor workflowStepProcessor;

	private WorkflowChainBuilder workflowChainBuilder;

	@BeforeEach
	void setUp()
	{
		workflowChainBuilder = new WorkflowChainBuilder(processorFactory);
	}

	/**
	 * Test Points covered: 1. Test buildChain() retrieves beans from context with correct bean
	 * names 2. Test buildChain() creates chain with handlers in correct phase order 3. Test
	 * buildChain() links handler.setNext() correctly
	 */
	@Test
	void testBuildChain_ConstructsCorrectChain()
	{
		String stepType = "validation";

		// Create 3 distinct configurations to verify order
		Map<String, Object> config1 = Map.of("stepId", "1", "action", "verify_email");
		Map<String, Object> config2 = Map.of("stepId", "2", "action", "verify_phone");
		Map<String, Object> config3 = Map.of("stepId", "3", "action", "verify_address");

		List<Map<String, Object>> stepConfigs = Arrays.asList(config1, config2, config3);

		// Mock the factory to return a processor when asked for "validation"
		when(processorFactory.getProcessor(stepType)).thenReturn(workflowStepProcessor);

		WorkflowStepHandler firstHandler = workflowChainBuilder.buildChain(stepType, stepConfigs);

		// Verify factory was called with the correct name (Bean Retrieval)
		verify(processorFactory, times(1)).getProcessor(stepType);

		// Verify First Handler exists and has correct config
		assertNotNull(firstHandler, "The first handler in the chain should not be null");
		Map<String, Object> actualConfig1 = (Map<String, Object>) ReflectionTestUtils
				.getField(firstHandler, "stepConfig");
		assertEquals(config1, actualConfig1,
				"First handler should contain the first configuration map");

		// Verify Linkage to Second Handler
		WorkflowStepHandler secondHandler = (WorkflowStepHandler) ReflectionTestUtils
				.getField(firstHandler, "nextHandler");
		assertNotNull(secondHandler, "First handler should be linked to a second handler");
		Map<String, Object> actualConfig2 = (Map<String, Object>) ReflectionTestUtils
				.getField(secondHandler, "stepConfig");
		assertEquals(config2, actualConfig2,
				"Second handler should contain the second configuration map");

		// Verify Linkage to Third Handler
		WorkflowStepHandler thirdHandler = (WorkflowStepHandler) ReflectionTestUtils
				.getField(secondHandler, "nextHandler");
		assertNotNull(thirdHandler, "The second handler should link to the third handler");
		Map<String, Object> actualConfig3 = (Map<String, Object>) ReflectionTestUtils
				.getField(thirdHandler, "stepConfig");
		assertEquals(config3, actualConfig3,
				"The third handler should have the correct configuration");

		// Verify End of Chain
		WorkflowStepHandler fourthHandler = (WorkflowStepHandler) ReflectionTestUtils
				.getField(thirdHandler, "nextHandler");
		assertNull(fourthHandler, "The third handler should not link to any further handlers");
	}

	/**
	 * Test Point: Test buildChain() handles empty phase configurations appropriately
	 */
	@Test
	void testBuildChain_WithEmptyConfig()
	{
		String stepType = "transform";
		List<Map<String, Object>> emptyConfigs = Collections.emptyList();

		WorkflowStepHandler result = workflowChainBuilder.buildChain(stepType, emptyConfigs);

		assertNull(result, "The result should be null when the configuration list is empty");
		verifyNoInteractions(processorFactory);
	}

	/**
	 * Test Point: Test buildChain() handles null phase configurations appropriately
	 */
	@Test
	void testBuildChain_WithNullConfig()
	{
		String stepType = "transform";

		WorkflowStepHandler result = workflowChainBuilder.buildChain(stepType, null);

		assertNull(result, "The result should be null when the configuration list is null");
		verifyNoInteractions(processorFactory);
	}

	/**
	 * Test Point: Test buildChain() throws Exception for missing/invalid bean names. Note: Testing
	 * for IllegalArgumentException as defined in the provided Factory class.
	 */
	@Test
	void testBuildChain_ThrowsException_WhenBeanNotFound()
	{
		String invalidStepType = "unknown_process";
		List<Map<String, Object>> stepConfigs = Collections.singletonList(Map.of("key", "val"));

		// Simulate Factory throwing exception when bean name is unknown
		when(processorFactory.getProcessor(invalidStepType)).thenThrow(new IllegalArgumentException(
				"No processor found for step type: " + invalidStepType));

		IllegalArgumentException exception = assertThrows(IllegalArgumentException.class,
				() -> workflowChainBuilder.buildChain(invalidStepType, stepConfigs));

		assertEquals("No processor found for step type: unknown_process", exception.getMessage(),
				"The exception message should indicate the missing processor for the invalid step type");
		verify(processorFactory).getProcessor(invalidStepType);
	}

	/**
	 * TEST POINT: Boundary Condition Test buildChain() with exactly one step to ensure loop handles
	 * single-item lists without attempting to link a non-existent second handler.
	 */
	@Test
	void testBuildChain_SingleStep()
	{
		String stepType = "email";
		Map<String, Object> expectedConfig = Map.of("id", "single");
		List<Map<String, Object>> stepConfigs = Collections.singletonList(expectedConfig);

		when(processorFactory.getProcessor(stepType)).thenReturn(workflowStepProcessor);

		WorkflowStepHandler result = workflowChainBuilder.buildChain(stepType, stepConfigs);

		assertNotNull(result, "The result should not be null for a single-step configuration");

		// Verify the handler has the correct configuration
		Map<String, Object> actualConfig = (Map<String, Object>) ReflectionTestUtils
				.getField(result, "stepConfig");
		assertNotNull(actualConfig, "The handler's configuration should not be null");
		assertEquals(expectedConfig, actualConfig,
				"The handler should have the correct configuration");

		// Verify nextHandler is null
		Object nextHandler = ReflectionTestUtils.getField(result, "nextHandler");
		assertNull(nextHandler, "Single step handler should not have a next handler");
	}

	/**
	 * TEST POINT: Robustness Test buildChain() when the input list contains a null element.
	 */
	@Test
	void testBuildChain_ListWithNulls()
	{

		String stepType = "validation";
		// List with one valid config and one null config
		List<Map<String, Object>> stepConfigs = Arrays.asList(Map.of("id", "1"), null);

		when(processorFactory.getProcessor(stepType)).thenReturn(workflowStepProcessor);

		WorkflowStepHandler firstHandler = workflowChainBuilder.buildChain(stepType, stepConfigs);

		assertNotNull(firstHandler,
				"The first handler should not be null even if the list contains null");

		// Verify second handler was created even with null config
		WorkflowStepHandler secondHandler = (WorkflowStepHandler) ReflectionTestUtils
				.getField(firstHandler, "nextHandler");
		assertNotNull(secondHandler,
				"The second handler should be created even for a null configuration");

		Map<String, Object> secondConfig = (Map<String, Object>) ReflectionTestUtils
				.getField(secondHandler, "stepConfig");
		assertNull(secondConfig, "The second handler should have a null configuration");
	}

	@Test
	void testBuildChain_NullStepType()
	{
		String stepType = null;
		List<Map<String, Object>> stepConfigs = Collections.singletonList(Map.of("id", "1"));

		when(processorFactory.getProcessor(stepType)).thenThrow(
				new IllegalArgumentException("No processor found for step type: " + stepType));
		IllegalArgumentException exception = assertThrows(IllegalArgumentException.class,
				() -> workflowChainBuilder.buildChain(stepType, stepConfigs));
		assertEquals("No processor found for step type: null", exception.getMessage(),
				"The exception message should indicate the missing processor for the null step type");
	}

	@Test
	void testBuildChain_SingleConfigWithNullValues()
	{
		String stepType = "validation";
		Map<String, Object> configWithNullValues = new HashMap<>();
		configWithNullValues.put("key", null); // Allows null values
		List<Map<String, Object>> stepConfigs = Collections.singletonList(configWithNullValues);

		when(processorFactory.getProcessor(stepType)).thenReturn(workflowStepProcessor);

		WorkflowStepHandler result = workflowChainBuilder.buildChain(stepType, stepConfigs);

		assertNotNull(result,
				"The handler should not be null even if the config contains null values");
		Map<String, Object> actualConfig = (Map<String, Object>) ReflectionTestUtils
				.getField(result, "stepConfig");
		assertEquals(configWithNullValues, actualConfig,
				"The handler should retain the null values in the config");
	}

	@Test
	void testBuildChain_MultipleChainsWithDifferentStepTypes()
	{
		String stepType1 = "validation";
		String stepType2 = "transformation";

		List<Map<String, Object>> stepConfigs1 = Collections.singletonList(Map.of("id", "1"));
		List<Map<String, Object>> stepConfigs2 = Collections.singletonList(Map.of("id", "2"));

		when(processorFactory.getProcessor(stepType1)).thenReturn(workflowStepProcessor);
		when(processorFactory.getProcessor(stepType2)).thenReturn(workflowStepProcessor);

		WorkflowStepHandler chain1 = workflowChainBuilder.buildChain(stepType1, stepConfigs1);
		WorkflowStepHandler chain2 = workflowChainBuilder.buildChain(stepType2, stepConfigs2);

		assertNotNull(chain1, "The first chain should not be null");
		assertNotNull(chain2, "The second chain should not be null");

		Map<String, Object> config1 = (Map<String, Object>) ReflectionTestUtils.getField(chain1,
				"stepConfig");
		Map<String, Object> config2 = (Map<String, Object>) ReflectionTestUtils.getField(chain2,
				"stepConfig");

		assertEquals(stepConfigs1.get(0), config1,
				"The first chain should have the correct configuration");
		assertEquals(stepConfigs2.get(0), config2,
				"The second chain should have the correct configuration");
	}
}


can you verify if these review comments are addressed:
in testBuildChain_SingleStep()- only verifies the handler exists but does not verify the handler has the correct config
Add context specific message to all asserts  to make test failures easy to troubleshoot
Please add test null step type.
Single config with null values. Test what happens when a config map contains null values.
Test verifying that calling buildChain multiple times with different step types works correctly and does not interfere with previous chains.
