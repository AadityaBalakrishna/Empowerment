public class CryptEngine implements ApplicationListener<ContextRefreshedEvent>, Encryptor, Decryptor
{
	protected static PcapLogger logger = PcapLoggerFactory.getPcapLogger(CryptEngine.class);

	@Value("${user.seed.minIdlePoolsize:10}")
	private int minIdleSeedPoolSize;

	@Value("${user.seed.maxIdlePoolsize:50}")
	private int maxIdleUserSeedPoolSize;

	@Value("${user.seed.maxPoolsize:1000}")
	private int maxUserSeedPoolSize;

	@Value("${user.seed.timeBetweenEvictionRunsInSeconds:30}")
	private int timeBetweenEvictionRunsInSeconds;

	static final String SAFEPAGE_USER_ID = "SAFEPAGE_USER_ID";
	static final String SAFEPAGE_PAYLOAD = "SAFEPAGE_PAYLOAD";

	public static final int GCM_INITIAL_VECTOR_LENGTH_BYTE = 12;
	public static final int GCM_AUTHENTICATION_TAG_LENGTH_BITS = 128;

	private final int MINIMUM_LENGTH_FOR_ENCRYPTED_STRINGS = 24;

	@Autowired
	private BeanFactory beanFactory;

	@Autowired
	private EpwKmsService epwKmsService;

	private KeyManager keyManager;

	private ObjectPool<String> pool;

	private SafePageExecutor spExecutor;

	/**
	 * A simple factory that generates encrypted user keys. There is no use for implementing
	 * destroyObject, validateObject, activateObject and passivateObject
	 */
	protected class EncryptedUserSeedFactory extends BasePooledObjectFactory<String>
	{
		@Override
		public String create()
		{
			try
			{
				String userPrimarySeed = getKeyManager().generateNewSeedValue();
				String encryptedSeed = encrypt(CryptType.SYSTEM_SECONDARY, userPrimarySeed);
				if (Utils.isNull(encryptedSeed))
				{
					throw new Exception(
							"generateUserPrimaryKey failed since encryptedSeed is null.");
				}
				return encryptedSeed;
			}
			catch (Exception e)
			{
				throw new RuntimeException("EncryptedUserSeedFactory failed: ", e);
			}
		}

		@Override
		public PooledObject<String> wrap(String obj)
		{
			return new DefaultPooledObject<String>(obj);
		}
	}

	/*
	 * Used by junits
	 */
	public void setKeyManager(KeyManager keyManager)
	{
		this.keyManager = keyManager;
	}

	protected KeyManager getKeyManager()
	{
		if (keyManager == null)
		{
			keyManager = (KeyManager) beanFactory.getBean("keyManager");
		}
		return keyManager;
	}

	protected SafePageExecutor getSafePageExecutor()
	{
		if (this.spExecutor == null)
		{
			this.spExecutor = (SafePageExecutor) beanFactory.getBean("spExecutor");
		}
		return this.spExecutor;
	}

	@PostConstruct
	public void init() throws Exception
	{
		// From: https://golb.hplar.ch/2017/10/JCE-policy-changes-in-Java-SE-8u151-and-8u152.html
		Security.setProperty("crypto.policy", "unlimited");
		CryptEngineFacade.setCryptEngine(this);
		try
		{
			logger.info("initializing CryptEngine; SYSTEM_PRIMARY key version is: "
					+ CryptType.SYSTEM_PRIMARY.getVersion());
			logger.info("initializing CryptEngine; SYSTEM_SECONDARY key version is: "
					+ CryptType.SYSTEM_SECONDARY.getVersion());
			logger.info("initializing CryptEngine; USER_PRIMARY key version is: "
					+ CryptType.USER_PRIMARY.getVersion());
			logger.info("initializing CryptEngine; USER_SECONDARY key version is: "
					+ CryptType.USER_SECONDARY.getVersion());
			logger.info(
					"initializing user seed pool minIdleSeedPoolSize:{},maxIdleSeedPoolSize:{},maxUserSeedPoolSize:{},timeBetweenEvictionRunsInSeconds:{} ",
					minIdleSeedPoolSize, maxIdleUserSeedPoolSize, maxUserSeedPoolSize,
					timeBetweenEvictionRunsInSeconds);

			if (System.getProperty("SKIP_CRYPT_POOL") != null)
			{
				this.minIdleSeedPoolSize = 1;
				this.maxIdleUserSeedPoolSize = 2;
				this.maxUserSeedPoolSize = 5;
				this.timeBetweenEvictionRunsInSeconds = 10;
				return;
			}

			this.getKeyManager()
					.getDefaultSystemSecondaryKey();

		}
		catch (Exception e)
		{
			logger.error("Error initializing CryptEngine: " + e.getMessage(), e);
		}
	}

	/**
	 * PLAT-3354: Reduce startup time by optimizing keyseed initialization only for ROOT
	 */
	@Override
	public void onApplicationEvent(ContextRefreshedEvent applicationEvent)
	{
		try
		{
			ServerConfigurer serverConfigurer = (ServerConfigurer) beanFactory
					.getBean("serverConfigurer");
			if (serverConfigurer == null || serverConfigurer.isDevOrLocalEnvironment()
					|| AppType.ROOT != serverConfigurer.getAppType())
			{
				return;
			}

			logger.info("Initializing KeySeed pool");

			CreatePrimaryKeySeed createPrimaryKeySeed = new CreatePrimaryKeySeed();
			this.getSafePageExecutor()
					.execute(createPrimaryKeySeed);
		}
		catch (BeansException ex)
		{
			// bean not found
		}
	}

	public String getVersion(CryptType cryptType)
	{
		return cryptType != null ? cryptType.getVersion() : null;
	}

	/**
	 * create generic object pool config
	 * 
	 * @return poolConfig
	 */
	protected GenericObjectPoolConfig createGenericObjectPoolConfig()
	{
		GenericObjectPoolConfig poolConfig = new GenericObjectPoolConfig();
		poolConfig.setMinIdle(minIdleSeedPoolSize);
		poolConfig.setMaxIdle(maxIdleUserSeedPoolSize);
		poolConfig.setMaxTotal(maxUserSeedPoolSize);
		poolConfig.setTimeBetweenEvictionRunsMillis(
				TimeUnit.SECONDS.toMillis(timeBetweenEvictionRunsInSeconds));
		poolConfig.setBlockWhenExhausted(false);
		return poolConfig;
	}

	/**
	 * Class used to create primary key seed of pool
	 * 
	 * @author jponsekar
	 */
	protected class CreatePrimaryKeySeed implements Runnable
	{
		public void run()
		{
			try
			{
				/*
				 * Initialize the EncryptedUserSeed pool by setting the pool size and the
				 * replenishing period.
				 */
				StopWatch stopWatch = new StopWatch();
				stopWatch.start();
				GenericObjectPoolConfig poolConfig = createGenericObjectPoolConfig();
				pool = new GenericObjectPool<String>(new EncryptedUserSeedFactory(), poolConfig);
				for (int i = 0; i < poolConfig.getMaxIdle(); i++)
				{
					pool.addObject();
				}
				logger.info("KeySeed pool initialization completed in {} ms.", stopWatch.getTime());
			}
			catch (Exception ex)
			{
				logger.error("Error initializing CreatePrimaryKeySeed: ", ex);
			}
		}
	}

	@Override
	public String encrypt(CryptType cryptType, String rawValue) throws Exception
	{
		if (CryptType.USER_PRIMARY.equals(cryptType) || CryptType.USER_SECONDARY.equals(cryptType))
		{
			logger.error("Crypt Type " + cryptType.name() + " Cannot  be used wih this method");
		}
		return encrypt(cryptType, rawValue, null);
	}

	public String decrypt(CryptType cryptType, String encryptedValue) throws Exception
	{
		return decrypt(cryptType, encryptedValue, (AuthUser) null);
	}

	@Override
	public String encrypt(CryptType cryptType, String rawValue, AuthUser user) throws Exception
	{
		if (Utils.isNull(rawValue))
		{
			return null;
		}

		switch (cryptType)
		{
			case SYSTEM_PRIMARY:
				return encryptUsingSystemPrimaryKey(rawValue);

			case SYSTEM_SECONDARY:
				return encryptUsingSystemSecondaryKey(rawValue);

			case USER_PRIMARY:
			case USER_SECONDARY:
				return encryptUsingUserKey(user, rawValue);

			default:
				throw new UnsupportedOperationException("Invalid CryptType: " + cryptType.name());
		}
	}

	@Override
	public boolean isEncryptedWithKey(CryptType cryptType, String encryptedValue)
	{
		switch (cryptType)
		{
			case SYSTEM_PRIMARY:
				return CryptType.SYSTEM_PRIMARY.matchesEncryptionVersions(encryptedValue);

			case SYSTEM_SECONDARY:
				return CryptType.SYSTEM_SECONDARY.matchesEncryptionVersions(encryptedValue);

			case USER_PRIMARY:
				return CryptType.USER_PRIMARY.matchesEncryptionVersions(encryptedValue);

			case USER_SECONDARY:
				return CryptType.USER_SECONDARY.matchesEncryptionVersions(encryptedValue);

			default:
				throw new UnsupportedOperationException(
						"Invalid CryptType provided: " + cryptType.name());
		}
	}

	/**
	 * If SYSTEM_PRIMARY version is 'V2' encrypt using AWS CMK, otherwise use keystore
	 *
	 * @param rawValue
	 * @return
	 * @throws Exception
	 */
	protected String encryptUsingSystemPrimaryKey(String rawValue) throws Exception
	{
		if (this.getKeyManager()
				.isSystmePrimaryKeyMigratedToAWS())
		{
			if (StringUtils.isEmpty(this.getKeyManager()
					.getSystemPrimaryAliasName()))
			{
				throw new SafePageException("systemPrimaryAliasName is null!");
			}
			EncryptRequestDTO req = new EncryptRequestDTO();
			req.setPlaintext(objectMapper.writeValueAsString(rawValue));
			req.setKeyId(this.getKeyManager().getSystemPrimaryAliasName());
			String result = epwKmsService.encrypt(req).getCiphertext();
			if (StringUtils.isNoneEmpty(result))
			{
				return CryptType.SYSTEM_PRIMARY.getVersion() + result;
			}
		}
		return null;
	}

cannot resolve objectmapper
