package com.personalcapital.cache.aop;

import io.micrometer.core.instrument.Metrics;
import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.Signature;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

public class PcapMultiCacheableAdviceTest {
    
    private PcapMultiCacheableAdvice cacheAdvice;
    private SimpleMeterRegistry meterRegistry;
    
    private static final String METRICS_NAME = "pcap.cache.event";
    
    @BeforeEach
    void setUp() {
        meterRegistry = new SimpleMeterRegistry();
        Metrics.addRegistry(meterRegistry);
        cacheAdvice = new PcapMultiCacheableAdvice();
    }

    @Test
    void testCacheMissMetric() {
        // Mock JoinPoint
        ProceedingJoinPoint pjp = mock(ProceedingJoinPoint.class);
        Signature mockSignature = mock(Signature.class);

        // Define behavior for class and method retrieval
        when(pjp.getTarget()).thenReturn(this);
        when(pjp.getSignature()).thenReturn(mockSignature);
        when(mockSignature.getName()).thenReturn("testMethod");

        // Call the recordCaching method
        cacheAdvice.recordCaching(pjp, "miss");

        // Assert that the counter is incremented
        assertEquals(1, meterRegistry.get(METRICS_NAME)
                .tag("class", this.getClass().getSimpleName())
                .tag("method", "testMethod")
                .tag("outcome", "miss")
                .counter().count());

        System.out.println("Cache Miss Metric Count: " +
                meterRegistry.get(METRICS_NAME).tag("outcome", "miss").counter().count());
    }
}
