package com.personalcapital.salesforce.sps;

import com.personalcapital.salesforce.sps.entity.SpsCirrusContactMetadata;
import com.personalcapital.salesforce.sps.enums.DataSource;
import com.personalcapital.salesforce.sps.enums.RegistrationStatus;
import com.personalcapital.salesforce.sps.enums.UserSpsPlanType;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Slice;
import org.springframework.test.annotation.Rollback;
import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;
import org.springframework.transaction.annotation.Transactional;

import com.personalcapital.salesforce.sps.repository.SpsCirrusContactMetadataRepository;
import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Rollback
@Transactional(value = "spTran")
@SpringJUnitConfig(locations = "classpath:spsCirrusApplicationContext.xml")
public class SpsCirrusContactMetadataRepositoryTest {

	@Autowired
	private SpsCirrusContactMetadataRepository repository;

	@PersistenceContext
	private EntityManager entityManager;

	private SpsCirrusContactMetadata entity1;
	private SpsCirrusContactMetadata entity2;

	private final UUID userGuid1 = UUID.randomUUID();
	private final UUID userGuid2 = UUID.randomUUID();
	private final UUID personaId1 = UUID.randomUUID();

	@BeforeEach
	public void setUp() {
		entity1 = new SpsCirrusContactMetadata();
		entity1.setUserAccountGuid(userGuid1);
		entity1.setPersonaId(personaId1);
		entity1.setUserSpsPlanType(UserSpsPlanType.CONFORMING);
		entity1.setRegistrationStatus(RegistrationStatus.PENDING);
		entity1.setDataSource(DataSource.ACCOUNT);
		entity1.setRetryCount(0);
		entity1.setUpdatedDate(new Date());
		repository.save(entity1);

		entity2 = new SpsCirrusContactMetadata();
		entity2.setUserAccountGuid(userGuid2);
		entity2.setPersonaId(UUID.randomUUID());
		entity2.setUserSpsPlanType(UserSpsPlanType.NON_CONFORMING);
		entity2.setRegistrationStatus(RegistrationStatus.COMPLETED);
		entity2.setDataSource(DataSource.C_AND_H);
		entity2.setRetryCount(2);
		entity2.setUpdatedDate(new Date());
		repository.save(entity2);

		entityManager.flush();
	}

	@Test
	public void testFindByMetadataId() {
		UUID id = entity1.getMetadataId();
		Assertions.assertNotNull(id, "Metadata ID should be generated upon save");

		Optional<SpsCirrusContactMetadata> found = repository.findByMetadataId(id);
		Assertions.assertTrue(found.isPresent(), "Entity should be found");
		Assertions.assertEquals(userGuid1, found.get().getUserAccountGuid());
	}

	@Test
	public void testFindLatestHashByUserAccountGuid() {
		UUID specificUser = UUID.randomUUID();

		SpsCirrusContactMetadata oldRecord = new SpsCirrusContactMetadata();
		oldRecord.setUserAccountGuid(specificUser);
		oldRecord.setPersonaId(UUID.randomUUID());
		oldRecord.setHashValue(100);
		oldRecord.setUpdatedDate(new Date(System.currentTimeMillis() - 10000));
		repository.save(oldRecord);

		SpsCirrusContactMetadata newRecord = new SpsCirrusContactMetadata();
		newRecord.setUserAccountGuid(specificUser);
		newRecord.setPersonaId(UUID.randomUUID());
		newRecord.setHashValue(200);
		newRecord.setUpdatedDate(new Date()); // Now
		repository.save(newRecord);

		entityManager.flush();

		Optional<Integer> latestHash = repository.findLatestHashByUserAccountGuid(specificUser);

		Assertions.assertTrue(latestHash.isPresent(), "Latest hash should be found");
		Assertions.assertEquals(200, latestHash.get(), "Should return the hash from the most recently updated record");
	}

	@Test
	public void testSetStatus() {
		Assertions.assertEquals(RegistrationStatus.PENDING, entity1.getRegistrationStatus());

		int rowsUpdated = repository.setStatus(userGuid1, personaId1, RegistrationStatus.FAILED);

		Assertions.assertEquals(1, rowsUpdated);

		Optional<SpsCirrusContactMetadata> updatedEntity = repository.findByMetadataId(entity1.getMetadataId());
		Assertions.assertTrue(updatedEntity.isPresent());
		Assertions.assertEquals(RegistrationStatus.FAILED, updatedEntity.get().getRegistrationStatus());
	}

	@Test
	public void testIncrementRetry() {
		int initialRetry = entity1.getRetryCount();

		int rowsUpdated = repository.incrementRetry(entity1.getMetadataId());
		Assertions.assertEquals(1, rowsUpdated);

		entityManager.clear();

		Optional<SpsCirrusContactMetadata> updatedEntity = repository.findByMetadataId(entity1.getMetadataId());
		Assertions.assertTrue(updatedEntity.isPresent());
		Assertions.assertEquals(initialRetry + 1, updatedEntity.get().getRetryCount());
	}

	@Test
	public void testFindAllByRegistrationStatus() {
		List<SpsCirrusContactMetadata> completed = repository.findAllByRegistrationStatus(RegistrationStatus.COMPLETED);

		Assertions.assertFalse(completed.isEmpty());
		Assertions.assertEquals(entity2.getMetadataId(), completed.get(0).getMetadataId());
	}

	@Test
	public void testFindByRegistrationStatusWithPagination() {
		createExtraEntity(RegistrationStatus.PENDING);
		createExtraEntity(RegistrationStatus.PENDING);

		Slice<SpsCirrusContactMetadata> slice = repository.findByRegistrationStatus(
				RegistrationStatus.PENDING, PageRequest.of(0, 2)
		);

		Assertions.assertFalse(slice.isEmpty(), "Slice should not be empty");
		Assertions.assertEquals(2, slice.getSize(), "Slice size should match the page size");
		Assertions.assertTrue(slice.getContent().stream()
						.allMatch(e -> e.getRegistrationStatus() == RegistrationStatus.PENDING),
				"All entities should have the PENDING status"
		);
	}

	@Test
	public void testFindExistingUsersByMetadataId() {
		List<UUID> metadataIds = Arrays.asList(entity1.getMetadataId(), entity2.getMetadataId());

		List<SpsCirrusContactMetadata> results = repository.findExistingUsersByMetadataId(metadataIds);

		Assertions.assertEquals(2, results.size(), "Should return two entities");
		Assertions.assertTrue(results.stream()
						.anyMatch(e -> e.getMetadataId().equals(entity1.getMetadataId())),
				"Entity1 should be in the results"
		);
		Assertions.assertTrue(results.stream()
						.anyMatch(e -> e.getMetadataId().equals(entity2.getMetadataId())),
				"Entity2 should be in the results"
		);
	}

	@Test
	public void testFindByUserAccountGuidAndPersonaId() {
		List<SpsCirrusContactMetadata> results = repository.findByUserAccountGuidAndPersonaId(
				userGuid1, personaId1
		);

		Assertions.assertFalse(results.isEmpty(), "Results should not be empty");
		Assertions.assertEquals(1, results.size(), "Should return one entity");
		Assertions.assertEquals(entity1.getMetadataId(), results.get(0).getMetadataId(),
				"Returned entity should match the expected metadataId"
		);
	}

	private void createExtraEntity(RegistrationStatus status) {
		SpsCirrusContactMetadata e = new SpsCirrusContactMetadata();
		e.setUserAccountGuid(UUID.randomUUID());
		e.setPersonaId(UUID.randomUUID());
		e.setRegistrationStatus(status);
		repository.save(e);
	}
}

error
16:36:39  [INFO] Running com.personalcapital.salesforce.sps.SpsCirrusContactMetadataRepositoryTest
16:36:39  [ERROR] Tests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 0.012 s <<< FAILURE! -- in com.personalcapital.salesforce.sps.SpsCirrusContactMetadataRepositoryTest
16:36:39  [ERROR] com.personalcapital.salesforce.sps.SpsCirrusContactMetadataRepositoryTest.testFindLatestHashByUserAccountGuid -- Time elapsed: 0.010 s <<< ERROR!
16:36:39  org.springframework.dao.IncorrectResultSizeDataAccessException: Query did not return a unique result: 2 results were returned
16:36:39  	at org.springframework.orm.jpa.vendor.HibernateJpaDialect.convertHibernateAccessException(HibernateJpaDialect.java:305)
16:36:39  	at org.springframework.orm.jpa.vendor.HibernateJpaDialect.convertHibernateAccessException(HibernateJpaDialect.java:256)
16:36:39  	at org.springframework.orm.jpa.vendor.HibernateJpaDialect.translateExceptionIfPossible(HibernateJpaDialect.java:244)
16:36:39  	at org.springframework.dao.support.ChainedPersistenceExceptionTranslator.translateExceptionIfPossible(ChainedPersistenceExceptionTranslator.java:61)
16:36:39  	at org.springframework.dao.support.DataAccessUtils.translateIfNecessary(DataAccessUtils.java:343)
16:36:39  	at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:160)
16:36:39  	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:184)
16:36:39  	at org.springframework.data.jpa.repository.support.CrudMethodMetadataPostProcessor$CrudMethodMetadataPopulatingMethodInterceptor.invoke(CrudMethodMetadataPostProcessor.java:136)
16:36:39  	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:184)
16:36:39  	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:223)
16:36:39  	at jdk.proxy2/jdk.proxy2.$Proxy294.findLatestHashByUserAccountGuid(Unknown Source)
16:36:39  	at com.personalcapital.salesforce.sps.SpsCirrusContactMetadataRepositoryTest.testFindLatestHashByUserAccountGuid(SpsCirrusContactMetadataRepositoryTest.java:99)
16:36:39  	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
16:36:39  	at java.base/java.util.ArrayList.forEach(ArrayList.java:1596)
16:36:39  	at java.base/java.util.ArrayList.forEach(ArrayList.java:1596)
16:36:39  Caused by: org.hibernate.NonUniqueResultException: Query did not return a unique result: 2 results were returned
16:36:39  	at org.hibernate.query.spi.AbstractSelectionQuery.uniqueElement(AbstractSelectionQuery.java:291)
16:36:39  	at org.hibernate.query.spi.AbstractSelectionQuery.getSingleResult(AbstractSelectionQuery.java:274)
16:36:39  	at org.springframework.data.jpa.repository.query.JpaQueryExecution$SingleEntityExecution.doExecute(JpaQueryExecution.java:226)
16:36:39  	at org.springframework.data.jpa.repository.query.JpaQueryExecution.execute(JpaQueryExecution.java:95)
16:36:39  	at org.springframework.data.jpa.repository.query.AbstractJpaQuery.doExecute(AbstractJpaQuery.java:160)
16:36:39  	at org.springframework.data.jpa.repository.query.AbstractJpaQuery.execute(AbstractJpaQuery.java:148)
16:36:39  	at org.springframework.data.repository.core.support.RepositoryMethodInvoker.doInvoke(RepositoryMethodInvoker.java:170)
16:36:39  	at org.springframework.data.repository.core.support.RepositoryMethodInvoker.invoke(RepositoryMethodInvoker.java:158)
16:36:39  	at org.springframework.data.repository.core.support.QueryExecutorMethodInterceptor.doInvoke(QueryExecutorMethodInterceptor.java:170)
16:36:39  	at org.springframework.data.repository.core.support.QueryExecutorMethodInterceptor.invoke(QueryExecutorMethodInterceptor.java:149)
16:36:39  	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:184)
16:36:39  	at org.springframework.data.projection.DefaultMethodInvokingMethodInterceptor.invoke(DefaultMethodInvokingMethodInterceptor.java:69)
16:36:39  	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:184)
16:36:39  	at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:380)
16:36:39  	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:119)
16:36:39  	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:184)
16:36:39  	at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:138)
16:36:39  	... 9 more
