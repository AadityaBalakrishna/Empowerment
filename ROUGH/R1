	from :

private KeyData generateUserKeyDataFromKeySeed(KeySeed userKeySeed, int keySize,
			String keyMaterialVersion) throws Exception
	{
		if (userKeySeed == null)
		{
			logger.error("Failed to GenerateUserKeyDataFromKeySeed; userKeySeed is null");
			return null;
		}

		String userKeySeedValue = CryptEngineFacade.decrypt(CryptType.SYSTEM_SECONDARY,
				userKeySeed.getValue());
		if (Utils.isNull(userKeySeedValue))
		{
			throw new Exception("Failed to decrypt user default keyseed value for keyseedId= "
					+ userKeySeed.getId() + " and userId= " + userKeySeed.getUserId());
		}
		/*
		 * CreateKeyFromSeed with the default key size and key versoin
		 */
		return new KeyData(this.createKeyFromSeed(userKeySeedValue, keySize, keyMaterialVersion),
				userKeySeed);
	}

got to this:

	/* Used to decrypt data that was encrypted using the System Secondary key. */
	public static String decrypt(CryptType cryptType, String encryptedValue) throws Exception
	{
		return cryptEngine.decrypt(cryptType, encryptedValue);
	}

goes to this:

	public String decrypt(CryptType cryptType, String encryptedValue) throws Exception
	{
		return decrypt(cryptType, encryptedValue, (AuthUser) null);
	}

goes to this:
/**
	 * the passed encryptedValue should contain the leading version and short key name. this method
	 * will use these values to determine how to decrypt the encrypted value
	 */
	@Override
	@SuppressWarnings("deprecation")
	public String decrypt(CryptType cryptType, String encryptedValue, AuthUser user)
			throws Exception
	{
		String result = null;

		if (Utils.isNotNull(encryptedValue))
		{
			switch (cryptType)
			{
				case SYSTEM_PRIMARY:
					result = decryptUsingSystemPrimaryKey(encryptedValue);
					break;

				case SYSTEM_SECONDARY:
					result = decryptUsingSystemSecondaryKey(encryptedValue);
					break;

				case USER_PRIMARY:
				case USER_SECONDARY:
					result = decryptUsingUserKey(user, encryptedValue);
					break;
				default:
					throw new UnsupportedOperationException(
							"Invalid CryptType: " + cryptType.name());
			}
		}
		return result;
	}

to these:
protected String decryptUsingSystemPrimaryKey(String encryptedValue) throws Exception
	{
		if (StringUtils.isEmpty(encryptedValue))
		{
			return null;
		}
		try
		{
			/*
			 * Data encrypted with system primary keys are formatted as [version][encrypted data];
			 * e.g. V1encrypteddata
			 */
			String version = CryptType.getVersionFromEncryptedData(encryptedValue);
			if (StringUtils.isNotEmpty(version))
			{
				encryptedValue = encryptedValue.substring(CryptType.SEED_VERSION_LENGTH);
				// System Primary key in AWS KMS will be version V2
				if (CryptType.V2.equals(version))
				{
					DecryptRequestDTO request = new DecryptRequestDTO();
					request.setCiphertext(encryptedValue);
					return epwKmsService.decrypt(request).getPlaintext();
				}
			}
		}
		catch (Exception anException)
		{
			logger.warn("Failed to decrypt because: ", anException);
		}
		return null;
	}

	protected String decryptUsingSystemSecondaryKey(String encryptedValue)
	{
		if (StringUtils.isEmpty(encryptedValue))
		{
			return null;
		}
		try
		{
			/*
			 * Data encrypted with system keys are formatted as [version][seed short name][encrypted
			 * data]; e.g. V1AAencrypteddata
			 */
			String seedName = null;
			String version = CryptType.getVersionFromEncryptedData(encryptedValue);
			String keyMaterialVersion = null;
			String transformation = null;
			/*
			 * version is null which signifies old encrypted value that was encrypted using AES128;
			 * after the values is decrypted, we will reencrypt using AES256. Expectation is that
			 * the caller will persist the newly encrypted value in db.
			 */
			if (Utils.isNull(version))
			{
				seedName = encryptedValue.substring(0,
						KeyManager.SYSTEM_SECONDARY_SEED_SHORTNAME_LENGTH);
				encryptedValue = encryptedValue
						.substring(KeyManager.SYSTEM_SECONDARY_SEED_SHORTNAME_LENGTH);
				logger.debug(
						"seedName = " + seedName + " and sub-encryptedValue = " + encryptedValue);
			}
			else
			{
				logger.debug("Encrypted data with SYSTEM_SECONDARY has version of: " + version);

				/*
				 * V4 format is [version][mode][keyseed name][encrypted data]; e.g.
				 * V4GCMAAencrypteddata
				 */
				if (CryptType.V4.equals(version))
				{
					/*
					 * Version V4 of system secondary key encryption using SHA-256 for key material
					 * and GCM for transformation
					 */
					keyMaterialVersion = KeyManager.DEFAULT_KEY_MATERIAL_HASH;
					transformation = KeyManager.ENCRYPTION_TRANSFORMATION_AES_GCM;

					// Remove MODE.length chars from V4 encrypted data for proper seedName retrieval
					encryptedValue = encryptedValue.substring(MODE.length());
				}
				seedName = encryptedValue.substring(CryptType.SEED_VERSION_LENGTH,
						CryptType.SEED_VERSION_LENGTH
								+ KeyManager.SYSTEM_SECONDARY_SEED_SHORTNAME_LENGTH);
				encryptedValue = encryptedValue.substring(CryptType.SEED_VERSION_LENGTH
						+ KeyManager.SYSTEM_SECONDARY_SEED_SHORTNAME_LENGTH);
				logger.debug(
						"seedName = " + seedName + " and sub-encryptedValue = " + encryptedValue);
			}
			return decrypt(CryptType.SYSTEM_SECONDARY, encryptedValue, this.getKeyManager()
					.getSystemSecondaryKeyByName(seedName, keyMaterialVersion)
					.getKey(), transformation);
		}
		catch (Exception e)
		{
			logger.warn("Failed to decrypt because: " + e, e);
		}
		return null;
	}

protected String decryptUsingUserKey(AuthUser authUser, String encryptedValue) throws Exception
	{
		/*
		 * PLAT-4204: The shortest encrypted data that we could possibly have in our DB is of
		 * length=24, which occurred when a single character was encrypted with a Key of size=128.
		 * This will protect against unnecessary errors that can/do occur when users try to decrypt
		 * an unencrypted String.
		 */
		if (encryptedValue.length() < MINIMUM_LENGTH_FOR_ENCRYPTED_STRINGS)
		{
			logger.info("Trying to decrypt unencrypted data for user_id={}", authUser.getId());
			return null;
		}

		if (authUser == null || authUser.getId() == null)
		{
			throw new Exception("User data decryption requires a user");
		}
		String result = null;
		try
		{
			/*
			 * PLAT-301: Add V5 for User_Primary; <br> Old data encrypted with user keys were
			 * formatted as [version][encrypted data]; e.g. V1encrypteddata <br>
			 *
			 * The current version- V3 - adds key seed name in the following format:
			 * [V3][userKeySeedName][encrypted data]; e.g. V3AAencrypteddata <br>
			 *
			 * The new version - V5 - adds 'GCM' after 'V5' in the following format:
			 * [V5GCM][userKeySeedName][encrypted data]; e.g. V5GCMAAencrypteddata
			 */
			String version = CryptType.getVersionFromEncryptedData(encryptedValue);
			int keySize;
			String seedName = null;
			String keyMaterialVersion = null;
			String transformation = null;
			/*
			 * Version is null which signifies old encrypted value using deprecated key size(128),
			 * which will need to be migrated by the user key rotation. The seedname for the user's
			 * first key is 'AA'.
			 */
			if (Utils.isNull(version))
			{
				seedName = CryptType.FIRST_USER_PRIMARYSEED_NAME;
				keySize = KeyManager.DEPRECATED_KEY_SIZE;
			}

			/*
			 * If version is 'V3', then using default key size(256) for key generation and SHA1 for
			 * key material. This occurs automatically in KeyManager.createKeyFromSeed.
			 *
			 * If version is 'V5', then using default key size(256) for key generation and SHA256
			 * for key material.
			 */
			else if (CryptType.V3.equals(version) || CryptType.V5.equals(version))
			{
				if (CryptType.V5.equals(version))
				{
					keyMaterialVersion = KeyManager.DEFAULT_KEY_MATERIAL_HASH;
					transformation = KeyManager.ENCRYPTION_TRANSFORMATION_AES_GCM;

					// Remove MODE.length chars from V5 encrypted data for proper seedName retrieval
					encryptedValue = encryptedValue.substring(MODE.length());
				}

				seedName = encryptedValue.substring(CryptType.SEED_VERSION_LENGTH,
						CryptType.SEED_VERSION_LENGTH
								+ KeyManager.USER_PRIMARY_SEED_SHORTNAME_LENGTH);
				encryptedValue = encryptedValue.substring(CryptType.SEED_VERSION_LENGTH
						+ KeyManager.USER_PRIMARY_SEED_SHORTNAME_LENGTH);
				keySize = KeyManager.DEFAULT_KEY_SIZE;
			}
			/*
			 * Version is V1 or V2, e.g. [version][encrypted data]; which signifies old encrypted
			 * value but using default key size(256), which will need to be migrated by the user key
			 * rotation. Also the key name is the user first key which is 'AA'
			 */
			else
			{
				seedName = CryptType.FIRST_USER_PRIMARYSEED_NAME;
				encryptedValue = encryptedValue.substring(CryptType.SEED_VERSION_LENGTH);
				keySize = KeyManager.DEFAULT_KEY_SIZE;
			}
			result = decrypt(CryptType.USER_PRIMARY, encryptedValue,
					getKeyManager()
							.getUserKeyByName(authUser, seedName, keySize, keyMaterialVersion)
							.getKey(),
					transformation);
			if (result == null)
			{
				logger.error(
						"Failed to decrypt user encrypted value for user_id={}; encryptedValue={}, keyName={}, version={}",
						authUser.getId(), encryptedValue, seedName, version);
				return null;
			}
			/*
			 * Encrypted values using user keys are formatted as {"SAFEPAGE_USER_ID"
			 * :"userId","SAFEPAGE_PAYLOAD":"decrypted data"}
			 * 
			 * This will ensure that no one can move encrypted data between users without causing
			 * data integrity issues.
			 */
			JSONObject jsonResult = null;
			try
			{
				jsonResult = JSONObject.fromObject(result);
				String payload = jsonResult.getString(SAFEPAGE_PAYLOAD);

				// PFM-6402
				Long userId = null;
				if (jsonResult.containsKey(SAFEPAGE_USER_ID) && jsonResult.get(jsonResult) != null)
				{
					userId = jsonResult.getLong(SAFEPAGE_USER_ID);
				}
				Long primaryUserId = authUser.isPersonDelegate() ? authUser.getUser()
						.getId() : authUser.getId();
				if (userId == null)
				{
					logger.debug(
							"Encrypted data does not have userId, primaryUserId:" + primaryUserId);
				}
				else
				{
					if (userId.longValue() != primaryUserId.longValue())
					{
						throw new SecurityException("Encrypted data does not belong to user.");
					}
				}
				result = payload;
			}
			catch (JSONException e)
			{
				logger.warn("Failed to decrypt value belonging to user_id={} because {}",
						authUser.getId(), e);
			}
		}
		catch (SecurityException e)
		{
			throw e;
		}
		catch (Exception e)
		{
			logger.error("Failed to decrypt value belonging to user_id={} because {}",
					authUser.getId(), e);
		}
		return result;
	}
