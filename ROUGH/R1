package com.empower.epw.aws.v2.kms;

import java.io.UnsupportedEncodingException;
import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.List;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.exception.ExceptionUtils;
import org.springframework.stereotype.Service;

import com.empower.epw.aws.api.kms.dto.DescribeKeyResponseDTO;
import com.empower.epw.aws.api.kms.dto.ListAliasesResponseDTO;
import com.empower.epw.aws.v2.kms.util.AwsExceptionHandler;
import com.personalcapital.log.PcapLogger;
import com.personalcapital.log.PcapLoggerFactory;
import com.safepage.error.SafePageErrorType;
import com.safepage.exception.SafePageException;
import com.empower.epw.aws.api.kms.EpwKmsService;
import com.safepage.util.Utils;
import software.amazon.awssdk.core.SdkBytes;
import software.amazon.awssdk.services.kms.KmsClient;
import software.amazon.awssdk.services.kms.model.DecryptRequest;
import software.amazon.awssdk.services.kms.model.DecryptResponse;
import software.amazon.awssdk.services.kms.model.DescribeKeyRequest;
import software.amazon.awssdk.services.kms.model.DescribeKeyResponse;
import software.amazon.awssdk.services.kms.model.DisabledException;
import software.amazon.awssdk.services.kms.model.EncryptRequest;
import software.amazon.awssdk.services.kms.model.EncryptResponse;
import software.amazon.awssdk.services.kms.model.InvalidCiphertextException;
import software.amazon.awssdk.services.kms.model.KeyUnavailableException;
import software.amazon.awssdk.services.kms.model.ListAliasesRequest;
import software.amazon.awssdk.services.kms.model.ListAliasesResponse;

@Service
public class EpwKmsServiceImpl implements EpwKmsService
{

	private static final PcapLogger logger = PcapLoggerFactory
			.getPcapLogger(EpwKmsServiceImpl.class);
	private static final Charset charset = StandardCharsets.UTF_8;

	private final KmsClient kmsClient;

	public EpwKmsServiceImpl(KmsClient kmsClient)
	{
		this.kmsClient = kmsClient;
	}

	@Override
	public String encryptUsingAWSKey(String plainText, String keyId) throws SafePageException
	{
		if (StringUtils.isEmpty(plainText))
		{
			throw new SafePageException(SafePageErrorType.INVALID_INPUT, "plainText is required!");
		}
		if (StringUtils.isEmpty(keyId))
		{
			throw new SafePageException(SafePageErrorType.INVALID_INPUT, "keyId is required!");
		}
		try
		{
			EncryptRequest encryptRequest = EncryptRequest.builder()
					.keyId(keyId)
					.plaintext(SdkBytes.fromByteBuffer(getByteBuffer(plainText)))
					.build();

			long start = System.currentTimeMillis();
			EncryptResponse result = kmsClient.encrypt(encryptRequest);
			if (result != null && result.ciphertextBlob() != null)
			{
				long end = System.currentTimeMillis();
				logger.info("[{}] encryptData took {} ", getAwsSdkVersion(), end - start);
				return Utils.encodeBase64(result.ciphertextBlob()
						.asByteArray());
			}
			else
			{
				logger.error("[{}] Failed to encryptUsingAWSKey, result is null!",
						getAwsSdkVersion());
				throw AwsExceptionHandler.handleKMSException(getAwsSdkVersion(), "encrypt", keyId,
						new IllegalStateException("Encrypt result or CipherTestBlob is null"));
			}
		}
		catch (DisabledException | KeyUnavailableException | UnsupportedEncodingException ex)
		{
			logger.error(String.format("[%s] Failed to encrypt, plainText:%s, keyId:%s, due to:%s",
					getAwsSdkVersion(), plainText, keyId, ex.getMessage()), ex);
			throw AwsExceptionHandler.handleKMSException(getAwsSdkVersion(), "encrypt", keyId, ex);
		}
	}

	@Override
	public String decryptUsingAWSKey(String cipherText) throws SafePageException
	{
		if (StringUtils.isEmpty(cipherText))
		{
			throw new SafePageException(SafePageErrorType.INVALID_INPUT, "cipherText is required!");
		}
		try
		{
			byte[] decodedCipherText = Utils.decodeBase64(cipherText);
			DecryptRequest decryptRequest = DecryptRequest.builder()
					.ciphertextBlob(SdkBytes.fromByteArray(decodedCipherText))
					.build();
			long start = System.currentTimeMillis();
			DecryptResponse result = kmsClient.decrypt(decryptRequest);
			long end = System.currentTimeMillis();
			logger.info("[{}] decryptData took {} ", getAwsSdkVersion(), end - start);
			return getString(result.plaintext()
					.asByteBuffer());
		}
		catch (KeyUnavailableException kue)
		{
			// The request was rejected because the specified CMK was not available. The request can
			// be retried.
			logger.error(
					"[{}] Failed to decryptUsingAWSKey(KeyUnavailableException), cipherText:{}, due to:{}",
					getAwsSdkVersion(), cipherText, ExceptionUtils.getMessage(kue), kue);
		}
		catch (InvalidCiphertextException ice)
		{
			// The request was rejected because the specified ciphertext, or additional
			// authenticated data incorporated
			// into the ciphertext, such as the encryption context, is corrupted, missing, or
			// otherwise invalid.
			logger.error(
					"[{}] Failed to decryptUsingAWSKey(InvalidCiphertextException), cipherText:{}, due to:{}",
					getAwsSdkVersion(), cipherText, ExceptionUtils.getMessage(ice), ice);
		}
		catch (DisabledException de)
		{
			logger.error(
					"[{}] Failed to decryptUsingAWSKey(DisabledException), cipherText:{}, due to:{}",
					getAwsSdkVersion(), cipherText, ExceptionUtils.getMessage(de), de);
		}
		catch (Exception ex)
		{
			logger.error("[{}] Failed to decryptUsingAWSKey, cipherText:{}, due to:{}",
					getAwsSdkVersion(), cipherText, ExceptionUtils.getMessage(ex), ex);
		}
		return null;
	}

	@Override
	@Deprecated
	public DescribeKeyResponseDTO describeKey(String keyId) {
		try
		{
			DescribeKeyResponse response = kmsClient.describeKey(DescribeKeyRequest.builder()
					.keyId(keyId)
					.build());
			return new DescribeKeyResponseDTO(response.keyMetadata()
					.keyId(),
					response.keyMetadata()
							.arn(),
					response.keyMetadata()
							.keyStateAsString(),
					response.keyMetadata()
							.enabled());
		}
		catch (Exception ex)
		{
			logger.error("[{}] Failed to describeKey, keyId:{}, due to:{}", getAwsSdkVersion(),
					keyId, ExceptionUtils.getMessage(ex), ex);
			return null;
		}
	}

	@Override
	@Deprecated
	public ListAliasesResponseDTO listAliases() {
		try
		{
			ListAliasesResponse response = kmsClient.listAliases(ListAliasesRequest.builder()
					.limit(100)
					.build());
			List<ListAliasesResponseDTO.AliasEntry> aliasEntries = response.aliases()
					.stream()
					.map(alias -> new ListAliasesResponseDTO.AliasEntry(alias.aliasName(),
							alias.targetKeyId()))
					.toList();
			return new ListAliasesResponseDTO(aliasEntries);
		}
		catch (Exception ex)
		{
			logger.error("[{}] Failed to listAliases, due to:{}", getAwsSdkVersion(),
					ExceptionUtils.getMessage(ex), ex);
			return null;
		}
	}

	@Override
	public String getAwsSdkVersion()
	{
		return "AWS SDK v2";
	}

	private ByteBuffer getByteBuffer(String string)
	{
		return ByteBuffer.wrap(string.getBytes(charset));
	}

	public static String getString(ByteBuffer byteBuffer)
	{
		byte[] byteArray = new byte[byteBuffer.remaining()];
		byteBuffer.get(byteArray);
		return new String(byteArray, charset);
	}
}

now how to refactor this v2 impl on the similar lines of v1 
