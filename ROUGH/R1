package com.personalcapital.cache.aop;

import com.personalcapital.cache.annotation.PcapMultiCacheable;
import com.personalcapital.cache.annotation.RedisType;
import com.personalcapital.cache.aop.support.CacheAdviceHelper;
import com.personalcapital.cache.aop.support.CacheKeyProvider;
import com.personalcapital.cache.utils.CacheConstants;
import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.Metrics;
import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.Signature;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.EnumSource;
import org.mockito.*;
import org.redisson.api.RBucket;
import org.redisson.api.RedissonClient;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;
import java.lang.reflect.Method;
import java.util.*;
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

@SpringJUnitConfig(locations = {"classpath:cachePushAdviceTest-Context.xml"})
public class PcapMultiCacheableAdviceMetricsTest {

    private enum TestScenario { CACHE_HIT, CACHE_MISS, CACHE_FAILURE, DATA_MISMATCH }

    @InjectMocks
    @Spy
    @Autowired
    private PcapMultiCacheableAdvice cacheAdvice;

    private SimpleMeterRegistry meterRegistry;
    private PcapMultiCacheable mockAnnotation;

    @Autowired
    @Qualifier(CacheConstants.REDISSON_REGULAR)
    private RedissonClient redissonClient;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        meterRegistry = new SimpleMeterRegistry();
        Metrics.addRegistry(meterRegistry);
        redissonClient = mock(RedissonClient.class);
        RBucket<Object> mockBucket = mock(RBucket.class);
        when(redissonClient.getBucket(anyString())).thenReturn(mockBucket);

        mockAnnotation = mock(PcapMultiCacheable.class);
        when(mockAnnotation.value()).thenReturn("testCache");
        when(mockAnnotation.keys()).thenReturn(new int[]{0});
        when(mockAnnotation.keyPrefix()).thenReturn("prefix");
        when(mockAnnotation.redisType()).thenReturn(RedisType.DEFAULT);
        when(mockAnnotation.keyProvider()).thenAnswer(invocation -> DummyCacheKeyProvider.class);
    }

    @ParameterizedTest
    @EnumSource(TestScenario.class)
    void testCacheMetricsThroughDoMultiCacheable(TestScenario scenario) throws Throwable {
        ProceedingJoinPoint pjp = mockProceedingJoinPoint();
        try (MockedStatic<Metrics> mockedMetrics = Mockito.mockStatic(Metrics.class)) {
            Counter mockCounter = mock(Counter.class);
            mockedMetrics.when(() -> Metrics.counter(anyString(), any(String[].class)))
                    .thenReturn(mockCounter);

            switch (scenario) {
                case CACHE_HIT:
                    when(redissonClient.getBucket(anyString()).get()).thenReturn("cachedValue");
                    break;
                case CACHE_MISS:
                    when(redissonClient.getBucket(anyString()).get()).thenReturn(null);
                    when(pjp.proceed()).thenReturn(Collections.singletonList("dbFetchedValue"));
                    break;
                case CACHE_FAILURE:
                    doThrow(new RuntimeException("Cache failure"))
                            .when(pjp).proceed();
                    break;
                case DATA_MISMATCH:
                    when(redissonClient.getBucket(anyString()).get()).thenReturn("staleData");
                    when(pjp.proceed()).thenReturn("freshData");
                    break;
            }

            Object result = cacheAdvice.doMultiCacheable(pjp, mockAnnotation);
            ArgumentCaptor<String> outcomeCaptor = ArgumentCaptor.forClass(String.class);

            assertNotNull(result);
            mockedMetrics.verify(() -> Metrics.counter(
                    eq("pcap.cache.event"), eq("class"), eq("PcapMultiCacheableAdvice"),
                    eq("method"), eq("dummyMethod"), eq("outcome"), outcomeCaptor.capture()),
                    atLeastOnce());

            List<String> capturedMetrics = outcomeCaptor.getAllValues();
            switch (scenario) {
                case CACHE_HIT:
                    assertTrue(capturedMetrics.contains("hit"));
                    break;
                case CACHE_MISS:
                    assertTrue(capturedMetrics.contains("miss"));
                    break;
                case CACHE_FAILURE:
                    assertTrue(capturedMetrics.contains("failure"));
                    break;
                case DATA_MISMATCH:
                    assertTrue(capturedMetrics.contains("data_mismatch"));
                    break;
            }
            verify(mockCounter, atLeastOnce()).increment();
        }
    }

    private ProceedingJoinPoint mockProceedingJoinPoint() throws Throwable {
        ProceedingJoinPoint pjp = mock(ProceedingJoinPoint.class);
        Signature mockSignature = mock(Signature.class);
        when(pjp.getTarget()).thenReturn(cacheAdvice);
        when(pjp.getSignature()).thenReturn(mockSignature);
        when(mockSignature.getName()).thenReturn("dummyMethod");
        when(pjp.getArgs()).thenReturn(new Object[]{Collections.singletonList("key1")});
        return pjp;
    }

    public static class DummyCacheKeyProvider implements CacheKeyProvider {
        @Override
        public Object getKeyField(Object value) {
            return value != null ? value.toString() : "null";
        }
    }
}
