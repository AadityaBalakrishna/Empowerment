encrypt - The method should throw a custom exception  back. It should not return null; it should always return a valid object. Remove return null; and add a throw in the exception. Just catch the AWS exception here; don't catch (Exception ex).

package com.empower.epw.sdk.v2.adapter.kms.util;

import com.empower.epw.aws.api.kms.exception.KMSOperationException;
import com.personalcapital.log.PcapLogger;
import com.personalcapital.log.PcapLoggerFactory;

public class AwsExceptionHandler {
    public static final String FAILURE_MSG_PREFIX = "[AWS SDK v2] Failed to ";

    private static final PcapLogger logger = PcapLoggerFactory
            .getPcapLogger(AwsExceptionHandler.class);

    public static KMSOperationException handleKMSException(String operation, String keyId, Exception e) {
        String errorMessage = String.format("'%s' KMS operation '%s' failed for keyId '%s': %s", FAILURE_MSG_PREFIX, keyId, e.getMessage());
        logger.error(errorMessage, e);
        return new KMSOperationException(errorMessage, e);
    }
}

package com.empower.epw.aws.api.kms.exception;

public class KMSOperationException extends RuntimeException{
    public KMSOperationException(String message, Throwable cause) {
        super(message, cause);
    }
}



v2 encrypt method, please utilis the above:

@Override
	public EncryptResponseDTO encrypt(EncryptRequestDTO request) throws SafePageException{
		if (StringUtils.isEmpty(request.getPlaintext())){
			throw new SafePageException(SafePageErrorType.INVALID_INPUT, "plainText is required!");
		}
		if (StringUtils.isEmpty(request.getKeyId())){
			throw new SafePageException(SafePageErrorType.INVALID_INPUT, "keyId is required!");
		}
		try{
			EncryptRequest encryptRequest = EncryptRequest.builder()
					.keyId(request.getKeyId())
					.plaintext(SdkBytes.fromByteBuffer(getByteBuffer(request.getPlaintext())))
					.build();

			long start = System.currentTimeMillis();
			EncryptResponse result = kmsClient.encrypt(encryptRequest);
			if (result != null && result.ciphertextBlob() != null) {
				long end = System.currentTimeMillis();
				logger.info("[{}] encryptData took {} ", getAwsSdkVersion(),(end - start));

				String encoded = Utils.encodeBase64(result.ciphertextBlob().asByteArray());
				return new EncryptResponseDTO(encoded);
			}
			logger.error("[{}] Failed to encryptUsingAWSKey, result is null!", getAwsSdkVersion());
			return new EncryptResponseDTO(null);
		}
		catch (DisabledException de)
		{
			logger.error(
					"[{}] Failed to encryptUsingAWSKey(DisabledException), plainText:{}, keyId:{}, due to:{}", getAwsSdkVersion(),
					request.getPlaintext(), request.getKeyId(), ExceptionUtils.getMessage(de), de);
		}
		catch (KeyUnavailableException kue)
		{
			logger.error(
					"[{}} Failed to encryptUsingAWSKey(KeyUnavailableException), plainText:{}, keyId:{}, due to:{}", getAwsSdkVersion(),
					request.getPlaintext(), request.getKeyId(), ExceptionUtils.getMessage(kue),
					kue);
		}
		catch (Exception ex)
		{
			logger.error("[{}] Failed to encryptUsingAWSKey, plainText:{}, keyId:{}, due to:{}", getAwsSdkVersion(),
					request.getPlaintext(), request.getKeyId(), ExceptionUtils.getMessage(ex), ex);
		}
		return null;
	}
