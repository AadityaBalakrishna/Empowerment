@Test
void testCacheMissMetricThroughDoMultiCacheable() throws Throwable
{
    ProceedingJoinPoint pjp = mockProceedingJoinPoint();

    try (MockedStatic<Metrics> mockedMetrics = Mockito.mockStatic(Metrics.class))
    {
        Counter mockCounter = mock(Counter.class);
        mockedMetrics.when(() -> Metrics.counter(anyString(), any(String[].class)))
                .thenReturn(mockCounter);

        // Simulate a cache miss by ensuring Redisson returns null
        when(redissonClient.getBucket(anyString()).get()).thenReturn(null);

        Object result = cacheAdvice.doMultiCacheable(pjp, mockAnnotation);

        assertNotNull(result);
        assertEquals("dbFetchedValue", result);  // Expect DB value due to cache miss

        // Capture all metric invocations
        ArgumentCaptor<String> outcomeCaptor = ArgumentCaptor.forClass(String.class);

        mockedMetrics.verify(() -> Metrics.counter(
                        eq("pcap.cache.event"), eq("class"), eq("PcapMultiCacheableAdvice"),
                        eq("method"), eq("testMethod"), eq("outcome"), outcomeCaptor.capture()),
                atLeastOnce()); // Allow multiple metric increments

        // Check that at least one metric matches "miss"
        assertTrue(outcomeCaptor.getAllValues().contains("miss"),
                "Expected 'miss' metric but got: " + outcomeCaptor.getAllValues());

        verify(mockCounter, atLeastOnce()).increment();
    }
}
