package com.personalcapital.cache.aop;

import io.micrometer.core.instrument.Metrics;
import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
import org.aspectj.lang.ProceedingJoinPoint;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

public class PcapMultiCacheableAdviceBasicTest {

    private PcapMultiCacheableAdvice cacheAdvice;
    private SimpleMeterRegistry meterRegistry;

    @BeforeEach
    void setUp() {
        meterRegistry = new SimpleMeterRegistry();  // Create a simple registry for testing
        Metrics.addRegistry(meterRegistry);        // Attach it to Micrometer
        cacheAdvice = new PcapMultiCacheableAdvice();  // Create a real instance (no mocks)
    }

    @Test
    void testCacheFailureMetric() throws Throwable {
        // Create a fake ProceedingJoinPoint (no Mockito)
        ProceedingJoinPoint pjp = new ProceedingJoinPoint() {
            @Override public Object proceed() { throw new RuntimeException("Simulated cache failure"); }
            @Override public Object getTarget() { return this; }
            @Override public String toShortString() { return "FakeJoinPoint"; }
            @Override public String getSignature() { return "testMethod"; }
            @Override public Object[] getArgs() { return new Object[]{List.of("key1")}; }
        };

        // Call the actual method (no mocking)
        try {
            cacheAdvice.doMultiCacheable(pjp, null);  // Null annotation for now
        } catch (Exception ignored) {
            // Expected failure, we are testing if the metric gets recorded
        }

        // ✅ Assert if the metric is recorded in Micrometer
        assertEquals(1, meterRegistry.get("pcap.cache.failure").counter().count(),
                     "Cache failure metric should be incremented");

        // ✅ Debugging Output
        System.out.println("✅ Cache Failure Metric Count: " + 
                           meterRegistry.get("pcap.cache.failure").counter().count());
    }
}