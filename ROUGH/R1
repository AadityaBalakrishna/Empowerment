	/**
	 * Use Case 1: Tests NON-RETRYABLE "Bad Data" errors.
	 * We send "FAIL_MESSAGE".
	 * We mock the service to throw a NonRetryableException.
	 * We verify the service was called once, and our ErrorHandler "swallowed" the error.
	 */
	@Test
	void testNonRetryableMessageIsLoggedAndDeleted()
	{
		String payload = "FAIL_MESSAGE";

		// Mock the service to throw the exception our ErrorHandler expects
		doThrow(new NonRetryableException("Test failure message"))
				.when(processingService)
				.processMessage(eq("DRY_RUN"), eq(payload), anyString());

		sqsTemplate.send(DRY_RUN_QUEUE, payload);
		await().atMost(5, TimeUnit.SECONDS)
				.untilAsserted(() ->
				{
					// Verify times(1) - this proves our ErrorHandler "swallowed" the
					// error (did not re-throw) and SQS considered it "handled".
					verify(processingService, times(1)).processMessage(eq("DRY_RUN"), eq(payload),
							anyString());
				});
	}

	/**
	 * Use Case 2: Tests RETRYABLE "Transient" errors.
	 * We send "TRANSIENT_ERROR".
	 * We mock the service to throw a RetryableException.
	 * We verify the service was called once, and our ErrorHandler "re-threw" the error.
	 */
	@Test
	void testRetryableErrorIsRetriedBySqs()
	{
		String payload = "TRANSIENT_ERROR";

		// Mock the service to throw the exception our ErrorHandler expects
		doThrow(new RetryableException(new SocketTimeoutException("Simulated DB timeout")))
				.when(processingService)
				.processMessage(eq("DRY_RUN"), eq(payload), anyString());

		sqsTemplate.send(DRY_RUN_QUEUE, payload);
		await().atMost(5, TimeUnit.SECONDS)
				.untilAsserted(() ->
				{
					// Verify times(1) - this proves Spring Retry is gone.
					// Our ErrorHandler re-threw the exception, so SQS will retry
					// after the visibilityTimeout (60s), which is outside this test.
					verify(processingService, times(1)).processMessage(eq("DRY_RUN"), eq(payload),
							anyString());
				});
	}

	/**
	 * Use Case 3: Tests NON-RETRYABLE "Code Bug" errors.
	 * We send "CODE_BUG".
	 * We mock the service to throw a NullPointerException.
	 * We verify the service was called once, and our ErrorHandler "swallowed" the error.
	 */
	@Test
	void testCodeBugIsCaughtAndLoggedAsNonRetryable()
	{
		String payload = "CODE_BUG";

		// Mock the service to throw a bug
		doThrow(new NullPointerException("Simulating Code failure"))
				.when(processingService)
				.processMessage(eq("DRY_RUN"), eq(payload), anyString());

		sqsTemplate.send(DRY_RUN_QUEUE, payload);

		await().atMost(5, TimeUnit.SECONDS)
				.untilAsserted(() ->
				{
					// Verify times(1) - this proves our ErrorHandler's "safety net"
					// correctly identified this as NON_RETRYABLE and swallowed it.
					verify(processingService, times(1)).processMessage(eq("DRY_RUN"), eq(payload),
							anyString());
				});
	}
