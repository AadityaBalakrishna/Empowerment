import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.redisson.api.RedissonClient;
import org.redisson.api.RBucket;
import org.redisson.api.RKeys;
import static org.mockito.Mockito.*;

public class PcapMultiCacheableAdviceTest {

    @Mock
    private RedissonClient redissonClient;

    @Mock
    private RBucket<String> rBucket;

    @Mock
    private RKeys rKeys;

    private PcapMultiCacheableAdvice spyAdvice;

    @BeforeEach
    void setUp() {
        // Initialize mocks
        MockitoAnnotations.openMocks(this);

        // Mocking RedissonClient's behavior
        when(redissonClient.getBucket(anyString())).thenReturn(rBucket);
        when(redissonClient.getKeys()).thenReturn(rKeys);

        // Mock the behavior of RBucket and RKeys
        when(rBucket.get()).thenReturn("cachedValue");  // Simulate fetching a cached value
        when(rKeys.delete(any(String[].class))).thenReturn(true); // Simulate successful deletion

        spyAdvice = spy(new PcapMultiCacheableAdvice());
    }

    @Test
    void testEvictionLogic() {
        // Simulating successful eviction
        when(rKeys.delete(any(String[].class))).thenReturn(true);

        // Simulate the actual logic where evictFromRedis() is called
        boolean result = spyAdvice.evictFromRedis(RedisType.GEN, Arrays.asList("key1", "key2"));

        // Verify the eviction logic worked as expected
        assertTrue(result);
        verify(rKeys, times(1)).delete(any(String[].class)); // Verifying that deletion was called
    }
}
