@Override
	// @Retryable(value =
	// {
	// Exception.class
	// }, maxAttempts = 3, backoff = @Backoff(delay = 1000))
	public String encryptUsingAWSKey(String plainText, String keyId) throws SafePageException
	{
		if (StringUtils.isEmpty(plainText))
		{
			throw new SafePageException(SafePageErrorType.INVALID_INPUT, "plainText is required!");
		}
		if (StringUtils.isEmpty(keyId))
		{
			throw new SafePageException(SafePageErrorType.INVALID_INPUT, "keyId is required!");
		}
		try
		{
			EncryptRequest encryptRequest = new EncryptRequest().withKeyId(keyId)
					.withPlaintext(getByteBuffer(plainText));
			long start = System.currentTimeMillis();
			EncryptResult result = kmsClient.encrypt(encryptRequest);
			if (result != null && result.getCiphertextBlob() != null)
			{
				long end = System.currentTimeMillis();
				logger.info("[{}] encryptData took {} ", getAwsSdkVersion(), end - start);
				return Base64.getEncoder().encodeToString(result.getCiphertextBlob().array());
			}
			else
			{
				throw AwsExceptionHandler.handleKMSException(getAwsSdkVersion(), "encrypt", keyId,
						new IllegalStateException("EncryptResult or CiphertextBlob is null"));
			}
		}
		catch (AmazonClientException ex)
		{
			logger.error(String.format("[%s] encryptUsingAWSKey failed, plainText:%s, keyId:%s, due to:%s",
					getAwsSdkVersion(), plainText, keyId, ex.getMessage()), ex);
			throw AwsExceptionHandler.handleKMSException(getAwsSdkVersion(), "encrypt", keyId, ex);
		}
	}

	/**
	 * Decrypt encrypted data key under AWS CMK Key using IAM role to access the key
	 */
	@Override
	// @Retryable(value =
	// {
	// Exception.class
	// }, maxAttempts = 3, backoff = @Backoff(delay = 1000))
	public String decryptUsingAWSKey(String cipherText) throws SafePageException
	{
		if (StringUtils.isEmpty(cipherText))
		{
			throw new SafePageException(SafePageErrorType.INVALID_INPUT, "cipherText is required!");
		}
		try
		{
			byte[] decodedCipherText = Utils.decodeBase64(cipherText);
			DecryptRequest decryptRequest = new DecryptRequest()
					.withCiphertextBlob(ByteBuffer.wrap(decodedCipherText));
			long start = System.currentTimeMillis();
			DecryptResult result = kmsClient.decrypt(decryptRequest);
			long end = System.currentTimeMillis();
			logger.info("[{}] decryptData took {}", getAwsSdkVersion(), end - start);
			ByteBuffer plainTextBlob = result.getPlaintext();
			return getString(plainTextBlob);
		}
		catch (KeyUnavailableException kue)
		{
			// The request was rejected because the specified CMK was not available. The request can
			// be retried.
			logger.error(
					"[{}] Failed to decryptUsingAWSKey(KeyUnavailableException), cipherText:{}, due to:{}",
					getAwsSdkVersion(), cipherText, ExceptionUtils.getMessage(kue), kue);
		}
		catch (InvalidCiphertextException ice)
		{
			// The request was rejected because the specified ciphertext, or additional
			// authenticated data incorporated
			// into the ciphertext, such as the encryption context, is corrupted, missing, or
			// otherwise invalid.
			logger.error(
					"[{}] Failed to decryptUsingAWSKey(InvalidCiphertextException), cipherText:{}, due to:{}",
					getAwsSdkVersion(), cipherText, ExceptionUtils.getMessage(ice), ice);
		}
		catch (DisabledException de)
		{
			logger.error(
					"[{}] Failed to decryptUsingAWSKey(DisabledException), cipherText:{}, due to:{}",
					getAwsSdkVersion(), cipherText, ExceptionUtils.getMessage(de), de);
		}
		catch (Exception ex)
		{
			logger.error("[{}] Failed to decryptUsingAWSKey, cipherText:{}, due to:{}",
					getAwsSdkVersion(), cipherText, ExceptionUtils.getMessage(ex), ex);
		}
		return null;
	}


can decrypt also be like encrypt?
