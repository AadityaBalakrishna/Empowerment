	void testCacheMissAndDataMisMatchMetricThroughDoMultiCacheable() throws Throwable
	{
		ProceedingJoinPoint pjp = mockProceedingJoinPoint();

		try (MockedStatic<Metrics> mockedMetrics = Mockito.mockStatic(Metrics.class))
		{
			Counter mockCounter = mock(Counter.class);
			mockedMetrics.when(() -> Metrics.counter(anyString(), any(String[].class)))
					.thenReturn(mockCounter);
			
			when(redissonClient.getBucket(anyString()).get()).thenReturn(null);
			when(pjp.proceed()).thenReturn(Collections.singletonList("dbFetchedValue"));
			
			Object result = cacheAdvice.doMultiCacheable(pjp, mockAnnotation);
			ArgumentCaptor<String> outcomeCaptor = ArgumentCaptor.forClass(String.class);
			
			assertNotNull(result);
			mockedMetrics.verify(() -> Metrics.counter(
							eq("pcap.cache.event"), eq("class"), eq("PcapMultiCacheableAdvice"),
							eq("method"), eq("dummyMethod"), eq("outcome"), outcomeCaptor.capture()),
					atLeastOnce());
			System.out.println("Captured Metrics: "+ outcomeCaptor.getAllValues());
			assertTrue(outcomeCaptor.getAllValues().contains("miss"));
			assertTrue(outcomeCaptor.getAllValues().contains("data_mismatch"));
			verify(mockCounter, atLeastOnce()).increment();
		}
	}

use that match nay, becaue next we'll test cache failure, and it'll have failure twice and data mismatch too, so to maintain uniformity and also use loggers no sys out println
