@Override
	@PcapCacheable(value = "historicalQuote", keyProvider = QuoteCacheKeyProvider.class)
	public List<Quote> getHistoricalValuesAsOf(SecurityId securityId, Date endDate,
			String periodType, Long periods)
	{
		if (securityId == null)
			return null;
		String symbol = securityId.getSymbol();
		if (Utils.isNotNull(symbol) && QuoteService.PCAP_CUSTOM_INDICES_MAP.containsKey(symbol))
		{
			SecurityId underlyingSecurityId = QuoteService.PCAP_CUSTOM_INDICES_MAP
					.get(securityId.getSymbol());
			log("getHistoricalValuesAsOf", securityId.getSymbol(), endDate, periodType, periods);

			List<Quote> underlyingQuotes = backingQuoteService
					.getHistoricalValuesAsOf(underlyingSecurityId, endDate, periodType, periods);

			log(symbol, endDate, periods, underlyingQuotes);

			if (underlyingQuotes == null)
				return null;

			return QuoteServiceUtils.getQuote(securityId, underlyingQuotes);
		}
		else if (CryptoCurrencyUtils.isCryptoHolding(securityId.getSymbol()))
		{
			log(securityId, endDate, true, "historyValueAsOf");
			if (!cryptoCacheUtils.isCryptoSymbolSupported(securityId))
			{
				log(securityId, "getHistoricalValuesAsOf");
				return null;
			}
			List<Quote> quotes = this.cryptoCompareQuoteService.getHistoricalValuesAsOf(securityId,
					endDate, periodType, periods);
			log(securityId, endDate, false, "historyValueAsOf");
			return quotes;
		}
		else
			return backingQuoteService.getHistoricalValuesAsOf(securityId, endDate, periodType,
					periods);
	}

	protected void log(String symbol, Date endDate, Long periods, List<Quote> underlyingQuotes)
	{
		// logging for PFM-11304 - issue only happen when period=364, and underlyingQuotes sz=252
		if (QuoteService.DEFAULT_INDEX_SYMBOLS_LIST_NEW.contains(symbol)
				&& (periods > 360 || underlyingQuotes.size() > 250))
		{
			int quoteListSz = underlyingQuotes.size();
			logger.info(
					"AnnotatedCachingQuoteService/getHistoricalValuesAsOf for ticker:{}, endDate:{},"
							+ " periods:{}, underlyingQuotes sz:{}",
					symbol, endDate, periods, quoteListSz);
			Quote quote0 = underlyingQuotes.get(0);
			Quote quote1 = underlyingQuotes.get(1);
			Quote quote3rdLast = underlyingQuotes.get(quoteListSz - 3);
			Quote quote2ndLast = underlyingQuotes.get(quoteListSz - 2);
			Quote quoteLast = underlyingQuotes.get(quoteListSz - 1);
			logger.info(
					"AnnotatedCachingQuoteService/getHistoricalValuesAsOf for ticker:{}, quote0 date:{}, quote0 price:{},"
							+ " quote1 date:{}, quote1 price:{}, quote3rdLast date:{}, quote3rdLast price:{}, "
							+ " quote2ndLast date:{}, quote2ndLast price:{}, "
							+ " quoteLast date:{}, quoteLast price:{}",
					symbol, quote0.getDate(), quote0.getLast(), quote1.getDate(), quote1.getLast(),
					quote3rdLast.getDate(), quote3rdLast.getLast(), quote2ndLast.getDate(),
					quote2ndLast.getLast(), quoteLast.getDate(), quoteLast.getLast());
		}
	}

	private void log(String method, String symbol, Date endDate, String periodType, Long periods)
	{
		logger.info(method + " [symbol:{},endDate:{},periodType:{},periods:{}]", symbol, endDate,
				periodType, periods);
	}

	private void log(SecurityId securityId, Date date, boolean isStartMsg, String reason)
	{
		if (isStartMsg)
		{
			logger.info(
					"Crypto before {} [exchangeCode:{},securityId:{},ticker:{},date:{},dummy:leftblank]",
					reason, securityId.getExchangeCode(), securityId.getSourceAssetId(),
					securityId.getTicker(), date);
		}
		else
		{
			logger.info(
					"Crypto after {} [exchangeCode:{},securityId:{},ticker:{},date:{},dummy:leftblank]",
					reason, securityId.getExchangeCode(), securityId.getSourceAssetId(),
					securityId.getTicker(), date);
		}
	}

	private void log(SecurityId securityId, String method)
	{
		logger.info(
				"Crypto coin is not supported [exchangeCode:{},securityId:{},ticker:{}, method:{}]",
				securityId.getExchangeCode(), securityId.getSourceAssetId(), securityId.getTicker(),
				method);
	}

	/**
	 * Redis key: {bhq}:DBC {bhq}:IAU {bhq}:VEU {bhq}:IGOV {bhq}:AGG {bhq}:VNQ {bhq}:VTI
	 */
	@Override
	@DateRangeCacheable(value = BENCHMARK_HISTORICAL_QUOTE_PREFIX_V2, key = "#securityId.symbol", resultKey = "#result.ticker", dateScoreField = "#result.dateObj", ttl = -1)
	public List<Quote> getHistoricalValuesDuring(@KeyParam("securityId") SecurityId securityId,
			@FromDate Date startDate, @ToDate Date endDate, String periodType)
	{
		return getHistoricalValuesAsOf(securityId, startDate, endDate, periodType);
	}

	@Override
	@DateRangeCachePut(value = BENCHMARK_HISTORICAL_QUOTE_PREFIX_V2, key = "#securityId.symbol", resultKey = "#result.ticker", dateScoreField = "#result.dateObj", uniqueId = "#result.dateObj", ttl = -1)
	public List<Quote> saveHistoricalValuesDuring(@KeyParam("securityId") SecurityId securityId,
			@FromDate Date startDate, @ToDate Date endDate, String periodType)
	{
		return getHistoricalValuesAsOf(securityId, startDate, endDate, periodType);
	}

	public List<Quote> getHistoricalValuesAsOf(SecurityId securityId, Date startDate, Date endDate,
			String periodType)
	{
		Long periods = Long
				.valueOf(DateTimeUtils.getDifferenceInDaysWithOutTimeStamp(startDate, endDate));
		if (securityId == null)
			return null;

		if (Utils.isNotNull(securityId.getSymbol())
				&& QuoteService.PCAP_CUSTOM_INDICES_MAP.containsKey(securityId.getSymbol()))
		{
			SecurityId underlyingSecurityId = QuoteService.PCAP_CUSTOM_INDICES_MAP
					.get(securityId.getSymbol());
			log("getHistoricalValuesAsOf", underlyingSecurityId, startDate, endDate, periodType);
			List<Quote> underlyingQuotes = backingQuoteService
					.getHistoricalValuesAsOf(underlyingSecurityId, endDate, periodType, periods);
			if (underlyingQuotes == null)
				return null;

			return QuoteServiceUtils.getQuote(securityId, underlyingQuotes);
		}
		else
		{
			log("getHistoricalValuesAsOf", securityId, startDate, endDate, periodType);
			return backingQuoteService.getHistoricalValuesAsOf(securityId, endDate, periodType,
					periods);
		}
	}
