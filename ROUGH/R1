package com.personalcapital.cache.aop;

import com.personalcapital.cache.annotation.PcapMultiCacheable;
import com.personalcapital.cache.annotation.RedisType;
import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.Metrics;
import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.Signature;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import org.redisson.api.RBucket;
import org.redisson.api.RedissonClient;
import org.redisson.spring.cache.CacheConfig;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest(classes = {PcapMultiCacheableAdvice.class, PcapMultiCacheableAdviceMetricsTest.TestConfig.class})
public class PcapMultiCacheableAdviceMetricsTest {

    @Autowired
    private PcapMultiCacheableAdvice cacheAdvice;

    private SimpleMeterRegistry meterRegistry;

    @MockBean
    private RedissonClient redissonClient;

    @MockBean
    private RBucket<Object> mockBucket;

    private PcapMultiCacheable mockAnnotation;

    @BeforeEach
    void setUp() {
        meterRegistry = new SimpleMeterRegistry();
        Metrics.addRegistry(meterRegistry);

        when(redissonClient.getBucket(anyString())).thenReturn(mockBucket);

        mockAnnotation = mock(PcapMultiCacheable.class);
        when(mockAnnotation.value()).thenReturn("testCache");
        when(mockAnnotation.keys()).thenReturn(new int[]{0});
        when(mockAnnotation.keyPrefix()).thenReturn("prefix");
        when(mockAnnotation.redisType()).thenReturn(RedisType.DEFAULT);
        when(mockAnnotation.keyProvider()).thenAnswer(invocation -> DummyCacheKeyProvider.class);
    }

    @Test
    void testCacheHitMetricThroughDoMultiCacheable() throws Throwable {
        ProceedingJoinPoint pjp = mockProceedingJoinPoint();
        when(mockBucket.get()).thenReturn("cachedValue"); // Simulate cache hit

        try (MockedStatic<Metrics> mockedMetrics = Mockito.mockStatic(Metrics.class)) {
            Counter mockCounter = mock(Counter.class);
            mockedMetrics.when(() -> Metrics.counter(anyString(), any(String[].class))).thenReturn(mockCounter);

            Object result = cacheAdvice.doMultiCacheable(pjp, mockAnnotation);

            assertNotNull(result);
            assertEquals("cachedValue", result);

            mockedMetrics.verify(() -> Metrics.counter("pcap.cache.event", "class", "PcapMultiCacheableAdvice",
                    "method", "testMethod", "outcome", "hit"), times(1));

            verify(mockCounter, times(1)).increment();
        }
    }

    private ProceedingJoinPoint mockProceedingJoinPoint() {
        ProceedingJoinPoint pjp = mock(ProceedingJoinPoint.class);
        Signature mockSignature = mock(Signature.class);
        when(pjp.getTarget()).thenReturn(cacheAdvice);
        when(pjp.getSignature()).thenReturn(mockSignature);
        when(mockSignature.getName()).thenReturn("testMethod");
        when(pjp.getArgs()).thenReturn(new Object[]{Collections.singletonList("key1")});
        return pjp;
    }

    public static class DummyCacheKeyProvider implements CacheKeyProvider {
        @Override
        public Object getKeyField(Object value) {
            return value != null ? value.toString() : "null";
        }
    }

    /*** Mock Config to provide required beans ***/
    @Configuration
    static class TestConfig {
        @Bean
        public Map<String, CacheConfig> redisCacheExpires() {
            Map<String, CacheConfig> cacheConfigMap = new HashMap<>();
            cacheConfigMap.put("testCache", new CacheConfig(1000, 2000)); // TTL and MaxIdleTime
            return cacheConfigMap;
        }
    }
}
