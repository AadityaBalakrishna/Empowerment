package com.personalcapital.cache.aop;

import io.micrometer.core.instrument.Metrics;
import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.Signature;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import org.redisson.api.RBucket;
import org.redisson.api.RedissonClient;

import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

import java.util.Arrays;
import java.util.List;

public class PcapMultiCacheableAdviceTest {
    
    private PcapMultiCacheableAdvice cacheAdvice;
    private SimpleMeterRegistry meterRegistry;
    private RedissonClient redissonClient;
    private RBucket<Object> mockBucket;

    @BeforeEach
    void setUp() {
        meterRegistry = new SimpleMeterRegistry();
        Metrics.addRegistry(meterRegistry);
        cacheAdvice = new PcapMultiCacheableAdvice();

        // Mock Redis behavior
        redissonClient = mock(RedissonClient.class);
        mockBucket = mock(RBucket.class);
        when(redissonClient.getBucket(anyString())).thenReturn(mockBucket);
    }

    /**
     * ✅ Test Case 1: Cache Hit
     * Ensures that when a value is found in the cache, the "hit" metric is recorded.
     */
    @Test
    void testCacheHitMetric() throws Throwable {
        ProceedingJoinPoint pjp = mockProceedingJoinPoint();
        when(mockBucket.get()).thenReturn("cachedValue"); // Simulate cache hit

        try (MockedStatic<Metrics> mockedMetrics = Mockito.mockStatic(Metrics.class)) {
            Counter mockCounter = mock(Counter.class);
            mockedMetrics.when(() -> Metrics.counter(anyString(), any(String[].class))).thenReturn(mockCounter);

            cacheAdvice.publishCacheMetrics(pjp, "hit");

            ArgumentCaptor<String> metricNameCaptor = ArgumentCaptor.forClass(String.class);
            ArgumentCaptor<String[]> tagCaptor = ArgumentCaptor.forClass(String[].class);

            mockedMetrics.verify(() -> Metrics.counter(metricNameCaptor.capture(), tagCaptor.capture()));

            assertEquals("pcap.cache.event", metricNameCaptor.getValue());
            verify(mockCounter, times(1)).increment();
        }
    }

    /**
     * ✅ Test Case 2: Cache Miss
     * Ensures that when a value is **not found** in the cache, the "miss" metric is recorded.
     */
    @Test
    void testCacheMissMetric() throws Throwable {
        ProceedingJoinPoint pjp = mockProceedingJoinPoint();
        when(mockBucket.get()).thenReturn(null); // Simulate cache miss

        try (MockedStatic<Metrics> mockedMetrics = Mockito.mockStatic(Metrics.class)) {
            Counter mockCounter = mock(Counter.class);
            mockedMetrics.when(() -> Metrics.counter(anyString(), any(String[].class))).thenReturn(mockCounter);

            cacheAdvice.publishCacheMetrics(pjp, "miss");

            ArgumentCaptor<String> metricNameCaptor = ArgumentCaptor.forClass(String.class);
            ArgumentCaptor<String[]> tagCaptor = ArgumentCaptor.forClass(String[].class);

            mockedMetrics.verify(() -> Metrics.counter(metricNameCaptor.capture(), tagCaptor.capture()));

            assertEquals("pcap.cache.event", metricNameCaptor.getValue());
            verify(mockCounter, times(1)).increment();
        }
    }

    /**
     * ✅ Test Case 3: Cache Failure
     * Simulates an exception in caching and verifies the "failure" metric is recorded.
     */
    @Test
    void testCacheFailureMetric() throws Throwable {
        ProceedingJoinPoint pjp = mockProceedingJoinPoint();
        doThrow(new RuntimeException("Cache failure simulated")).when(pjp).proceed();

        try (MockedStatic<Metrics> mockedMetrics = Mockito.mockStatic(Metrics.class)) {
            Counter mockCounter = mock(Counter.class);
            mockedMetrics.when(() -> Metrics.counter(anyString(), any(String[].class))).thenReturn(mockCounter);

            try {
                cacheAdvice.doMultiCacheable(pjp, null);
            } catch (Exception ignored) {
                // Exception expected, no need to handle
            }

            mockedMetrics.verify(() -> Metrics.counter("pcap.cache.event", "class", "PcapMultiCacheableAdvice",
                    "method", "testMethod", "outcome", "failure"), times(1));

            verify(mockCounter, times(1)).increment();
        }
    }

    /**
     * ✅ Test Case 4: Cache Eviction Failure
     * Simulates a scenario where cache eviction fails, and verifies that the correct metric is incremented.
     */
    @Test
    void testCacheEvictionFailureMetric() throws Throwable {
        ProceedingJoinPoint pjp = mockProceedingJoinPoint();
        PcapMultiCacheableAdvice spyAdvice = spy(cacheAdvice);
        
        doThrow(new RuntimeException("Cache eviction failed")).when(spyAdvice).evictFromRedis(any(), anyList());

        try (MockedStatic<Metrics> mockedMetrics = Mockito.mockStatic(Metrics.class)) {
            Counter mockCounter = mock(Counter.class);
            mockedMetrics.when(() -> Metrics.counter(anyString(), any(String[].class))).thenReturn(mockCounter);

            try {
                spyAdvice.doMultiCacheable(pjp, null);
            } catch (Exception ignored) {
                // Exception expected, no need to handle
            }

            mockedMetrics.verify(() -> Metrics.counter("pcap.cache.event", "class", "PcapMultiCacheableAdvice",
                    "method", "testMethod", "outcome", "eviction_failure"), times(1));

            verify(mockCounter, times(1)).increment();
        }
    }

    // ========== Utility Methods ==========

    /**
     * Creates a mocked ProceedingJoinPoint with a fake method signature.
     */
    private ProceedingJoinPoint mockProceedingJoinPoint() {
        ProceedingJoinPoint pjp = mock(ProceedingJoinPoint.class);
        Signature mockSignature = mock(Signature.class);

        when(pjp.getTarget()).thenReturn(cacheAdvice);
        when(pjp.getSignature()).thenReturn(mockSignature);
        when(mockSignature.getName()).thenReturn("testMethod");

        return pjp;
    }
}
