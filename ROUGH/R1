package com.personalcapital.cache.aop;

import com.personalcapital.cache.testframework.CacheTestConfiguration;
import com.personalcapital.cache.annotation.PcapMultiCacheable;
import io.micrometer.core.instrument.Metrics;
import io.micrometer.core.instrument.Counter;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.Signature;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.MockedStatic;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

import java.util.Arrays;

@SpringBootTest(classes = CacheTestConfiguration.class)  // ✅ Load Spring Context
public class PcapMultiCacheableAdviceTest {

    @Autowired
    private PcapMultiCacheableAdvice cacheAdvice;  // ✅ Inject the real bean

    @BeforeEach
    void setUp() {
        // No need to manually initialize cacheAdvice, Spring injects it
    }

    @Test
    void testPublishCacheMetrics_onEvictionFailure() throws Throwable {
        ProceedingJoinPoint pjp = mock(ProceedingJoinPoint.class);
        Signature mockSignature = mock(Signature.class);

        when(pjp.getTarget()).thenReturn(cacheAdvice);
        when(pjp.getSignature()).thenReturn(mockSignature);
        when(pjp.getSignature().getName()).thenReturn("testMethod");
        when(pjp.getArgs()).thenReturn(new Object[]{"testKey"});

        // ✅ Mock the annotation instead of passing null
        PcapMultiCacheable mockAnnotation = mock(PcapMultiCacheable.class);
        when(mockAnnotation.resultKeyField()).thenReturn("id"); 
        when(mockAnnotation.nullable()).thenReturn(false);
        when(mockAnnotation.keyPrefix()).thenReturn("test_prefix");
        when(mockAnnotation.value()).thenReturn("test_cache");
        when(mockAnnotation.redisType()).thenReturn(null);
        when(mockAnnotation.keys()).thenReturn(new int[]{0});

        // Mock eviction failure
        PcapMultiCacheableAdvice spyAdvice = spy(cacheAdvice);  // ✅ Use real injected bean
        doThrow(new RuntimeException("Cache eviction failed")).when(spyAdvice).evictFromRedis(any(), anyList());

        try (MockedStatic<Metrics> mockedMetrics = mockStatic(Metrics.class)) {
            Counter mockCounter = mock(Counter.class);
            mockedMetrics.when(() -> Metrics.counter(anyString(), any(String[].class)))
                         .thenReturn(mockCounter);

            // Act
            try {
                spyAdvice.doMultiCacheable(pjp, mockAnnotation);
            } catch (Exception e) {
                System.out.println("Caught Exception: " + e.getMessage());
            }

            // Verify `evictFromRedis` was actually called
            verify(spyAdvice, times(1)).evictFromRedis(any(), anyList());

            // Verify `publishCacheMetrics` was called with "eviction_failure"
            verify(spyAdvice, times(1)).publishCacheMetrics(eq(pjp), eq("eviction_failure"));

            // Verify Metrics.counter() was called
            mockedMetrics.verify(() -> Metrics.counter(eq("pcap.cache.event"), any(String[].class)), times(1));

            // Verify counter increment
            verify(mockCounter, times(1)).increment();
        }
    }
}
