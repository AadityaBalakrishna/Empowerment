@SuppressWarnings("unchecked")
@Around("@annotation(pcapMultiCacheable)")
public Object doMultiCacheable(ProceedingJoinPoint pjp, PcapMultiCacheable pcapMultiCacheable)
        throws Throwable {
    Method method = null;
    Object[] args = pjp.getArgs();
    Class<?> returnType = null;
    Integer listKeyArgIndex = null;
    Collection<Object> listKeyArg = new ArrayList<>();
    Collection<Object> otherKeyArgs = new ArrayList<>();
    Collection<Object> missedListKeys = null;
    Object[] modifiedArgs = null;
    boolean resultIsCollection = true;

    String resultKeyField = pcapMultiCacheable.resultKeyField();
    String[] resultKeyFields = pcapMultiCacheable.resultKeyFields();
    boolean cachedValueNullable = pcapMultiCacheable.nullable();
    String keyPrefix = pcapMultiCacheable.keyPrefix();
    Collection<Object> collectionResult = null;
    Map<Object, Object> mapResult = null;
    Map<Object, Object> keyValueMap = new LinkedHashMap<>();
    String cacheName = pcapMultiCacheable.value();
    RedisType redisType = pcapMultiCacheable.redisType();

    if (StringUtils.isBlank(cacheName)) {
        throw new AopInvocationException("pcapMultiCacheable needs to have cacheName specified in value element.");
    }

    CacheKeyProvider cacheKeyProvider = pcapMultiCacheable.keyProvider().getDeclaredConstructor().newInstance();
    try {
        method = CacheAdviceHelper.getMethod(pjp);
        returnType = method.getReturnType();

        if (Collection.class.isAssignableFrom(returnType)) {
            resultIsCollection = true;
            collectionResult = collectionInstance((Class<? extends Collection>) returnType);
        } else if (Map.class.isAssignableFrom(returnType)) {
            resultIsCollection = false;
            mapResult = mapInstance((Class<? extends Map>) returnType);
        } else {
            throw new AopInvocationException("pcapMultiCacheable cannot apply to method without return.");
        }

        int[] keyIndice = pcapMultiCacheable.keys();
        if (args == null || args.length == 0) {
            throw new AopInvocationException("pcapMultiCacheable cannot apply to method without parameter");
        }

        if (keyIndice == null || keyIndice.length == 0) {
            for (int i = 0; i < args.length; i++) {
                Object arg = args[i];
                if (Collection.class.isInstance(arg) && Collection.class.isAssignableFrom(arg.getClass())) {
                    listKeyArgIndex = i;
                } else {
                    otherKeyArgs.add(cacheKeyProvider.getKeyField(arg));
                }
            }
        } else {
            for (int keyIndex : keyIndice) {
                if (keyIndex >= args.length) continue;
                Object arg = args[keyIndex];
                if (Collection.class.isInstance(arg) && Collection.class.isAssignableFrom(arg.getClass())) {
                    listKeyArgIndex = keyIndex;
                } else {
                    otherKeyArgs.add(cacheKeyProvider.getKeyField(arg));
                }
            }
        }

        if (listKeyArgIndex == null) {
            throw new AopInvocationException("pcapMultiCacheable must have a Collection parameter as key list");
        }

        listKeyArg = (Collection<Object>) args[listKeyArgIndex];
        for (Object listKey : listKeyArg) {
            String key = CacheUtils.generateKey(cacheName, keyPrefix, cacheKeyProvider.getKeyField(listKey), otherKeyArgs);
            Object cachedValue = getRedisson(redisType).getBucket(key).get();

            if (cachedValue == null || (cachedValue instanceof ObjectUtils.Null && !cachedValueNullable)) {
                if (missedListKeys == null) {
                    missedListKeys = collectionInstance(listKeyArg.getClass());
                }
                missedListKeys.add(listKey);
            } else {
                keyValueMap.put(listKey, CacheUtils.getValue(cachedValue));

                // Log & Increment Datadog Metric for Cache Hit
                logger.info("Cache hit in class: {}, method: {}", pjp.getTarget().getClass().getSimpleName(), pjp.getSignature().getName());
                Counter cacheHitCounter = Metrics.counter("pcap.cache.event", 
                        "class", pjp.getTarget().getClass().getSimpleName(),
                        "method", pjp.getSignature().getName(),
                        "outcome", "hit");
                cacheHitCounter.increment();
            }
        }

        if (missedListKeys == null || missedListKeys.isEmpty()) {
            if (resultIsCollection) return getCollectionResult(listKeyArg, keyValueMap, collectionResult);
            else return getMapResult(listKeyArg, keyValueMap, mapResult);
        }

        // Log & Increment Datadog Metric for Cache Miss
        logger.info("Cache miss in class: {}, method: {}", pjp.getTarget().getClass().getSimpleName(), pjp.getSignature().getName());
        Counter cacheMissCounter = Metrics.counter("pcap.cache.event", 
                "class", pjp.getTarget().getClass().getSimpleName(),
                "method", pjp.getSignature().getName(),
                "outcome", "miss");
        cacheMissCounter.increment();

        modifiedArgs = modifiedArgs(args, listKeyArgIndex, missedListKeys);
    } catch (Exception ex) {
        logger.info("Cache failure in class: {}, method: {}. Error: {}", 
                pjp.getTarget().getClass().getSimpleName(), 
                pjp.getSignature().getName(), 
                ex.getMessage());

        // Increment Datadog Metric for Cache Failure
        Counter cacheFailureCounter = Metrics.counter("pcap.cache.event", 
                "class", pjp.getTarget().getClass().getSimpleName(), 
                "method", pjp.getSignature().getName(), 
                "outcome", "failure");
        cacheFailureCounter.increment();
    }

    final Object resultForMissed = pjp.proceed(modifiedArgs);
    int ttlSeconds = getTtlFromConfiguration(cacheName, pcapMultiCacheable.ttlSeconds());

    try {
        // If successful, store to cache
        Metrics.counter("pcap.cache.event", 
                "class", pjp.getTarget().getClass().getSimpleName(),
                "method", pjp.getSignature().getName(),
                "outcome", "store").increment();
    } catch (Exception ex) {
        // Log & Increment Datadog Metric for Data Mismatch
        logger.warn("Data mismatch warning in class: {}, method: {}", pjp.getTarget().getClass().getSimpleName(), pjp.getSignature().getName());
        Counter dataMismatchCounter = Metrics.counter("pcap.cache.event", 
                "class", pjp.getTarget().getClass().getSimpleName(),
                "method", pjp.getSignature().getName(),
                "outcome", "mismatch");
        dataMismatchCounter.increment();
    }

    return resultForMissed;
}