@Test
void testExceptionTriggersFailureMetric() throws Throwable {
    ProceedingJoinPoint pjp = mockProceedingJoinPoint();
    PcapMultiCacheable annotation = mockPcapMultiCacheable();
    PcapMultiCacheableAdvice spyAdvice = spy(new PcapMultiCacheableAdvice());

    // ✅ Force an exception inside doMultiCacheable
    when(pjp.proceed()).thenThrow(new RuntimeException("Simulated exception"));

    try (MockedStatic<Metrics> mockedMetrics = mockStatic(Metrics.class)) {
        Counter mockCounter = mock(Counter.class);
        mockedMetrics.when(() -> Metrics.counter(anyString(), any(String[].class)))
                     .thenReturn(mockCounter);

        try {
            spyAdvice.doMultiCacheable(pjp, annotation);
        } catch (Exception ignored) { }

        // ✅ Verify `publishCacheMetrics("failure")` was actually called
        verify(spyAdvice, times(1)).publishCacheMetrics(eq(pjp), eq("failure"));

        // ✅ Capture arguments passed to Metrics.counter()
        ArgumentCaptor<String> metricNameCaptor = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<String[]> tagsCaptor = ArgumentCaptor.forClass(String[].class);

        mockedMetrics.verify(() -> Metrics.counter(metricNameCaptor.capture(), tagsCaptor.capture()), times(1));
        verify(mockCounter, times(1)).increment();

        // ✅ Ensure metric tags contain "failure"
        List<String> capturedTags = Arrays.asList(tagsCaptor.getValue());
        assertTrue(capturedTags.contains("outcome"), "Tags should contain 'outcome'");
        assertTrue(capturedTags.contains("failure"), "Tags should contain 'failure'");
    }
}

@Test
void testEvictionFailureTriggersMetric() throws Throwable {
    ProceedingJoinPoint pjp = mockProceedingJoinPoint();
    PcapMultiCacheable annotation = mockPcapMultiCacheable();
    PcapMultiCacheableAdvice spyAdvice = spy(new PcapMultiCacheableAdvice());

    // ✅ Ensure eviction fails
    doThrow(new RuntimeException("Eviction failed")).when(spyAdvice).evictFromRedis(any(), anyList());

    try (MockedStatic<Metrics> mockedMetrics = mockStatic(Metrics.class)) {
        Counter mockCounter = mock(Counter.class);
        mockedMetrics.when(() -> Metrics.counter(anyString(), any(String[].class)))
                     .thenReturn(mockCounter);

        try {
            spyAdvice.doMultiCacheable(pjp, annotation);
        } catch (Exception ignored) { }

        // ✅ Verify `publishCacheMetrics("eviction_failure")` was called
        verify(spyAdvice, times(1)).publishCacheMetrics(eq(pjp), eq("eviction_failure"));

        // ✅ Capture arguments passed to Metrics.counter()
        ArgumentCaptor<String> metricNameCaptor = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<String[]> tagsCaptor = ArgumentCaptor.forClass(String[].class);

        mockedMetrics.verify(() -> Metrics.counter(metricNameCaptor.capture(), tagsCaptor.capture()), times(1));
        verify(mockCounter, times(1)).increment();

        // ✅ Ensure metric tags contain "eviction_failure"
        List<String> capturedTags = Arrays.asList(tagsCaptor.getValue());
        assertTrue(capturedTags.contains("outcome"), "Tags should contain 'outcome'");
        assertTrue(capturedTags.contains("eviction_failure"), "Tags should contain 'eviction_failure'");
    }
}
