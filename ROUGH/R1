test a:
package com.personalcapital.cache.aop;

import com.personalcapital.cache.annotation.PcapMultiCacheable;
import com.personalcapital.cache.annotation.RedisType;
import com.personalcapital.cache.aop.support.CacheAdviceHelper;
import com.personalcapital.cache.aop.support.CacheKeyProvider;
import com.personalcapital.cache.utils.CacheConstants;
import com.personalcapital.log.PcapLogger;
import com.personalcapital.log.PcapLoggerFactory;
import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.Metrics;
import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.Signature;
import org.junit.jupiter.api.*;
import org.mockito.*;
import org.redisson.api.RBucket;
import org.redisson.api.RKeys;
import org.redisson.api.RedissonClient;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.test.context.TestPropertySource;
import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;

import java.util.*;

import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

@SpringJUnitConfig(locations = "classpath:cachePushAdviceTest-Context.xml")
public class PcapMultiCacheableAdviceMetricsTest
{
	@InjectMocks
	@Spy
	@Autowired
	private PcapMultiCacheableAdvice cacheAdvice;

	private SimpleMeterRegistry meterRegistry;
	private PcapMultiCacheable mockAnnotation;

	@Autowired
	@Qualifier(CacheConstants.REDISSON_REGULAR)
	private RedissonClient redissonClient;

	private static final PcapLogger logger = PcapLoggerFactory
			.getPcapLogger(PcapMultiCacheableAdviceMetricsTest.class);
	private static MockedStatic<CacheAdviceHelper> mockedCacheAdviceHelper;

	@BeforeAll
	static void initMockedStatic()
	{
		mockedCacheAdviceHelper = mockStatic(CacheAdviceHelper.class);
	}

	@BeforeEach
	void setUp() throws NoSuchMethodException
	{
		MockitoAnnotations.openMocks(this);
		meterRegistry = new SimpleMeterRegistry();
		Metrics.addRegistry(meterRegistry);

		redissonClient = mock(RedissonClient.class);
		RBucket<Object> mockBucket = mock(RBucket.class);
		doReturn(redissonClient).when(cacheAdvice)
				.getRedisson(RedisType.GEN);
		when(redissonClient.getBucket(anyString())).thenReturn(mockBucket);

		mockAnnotation = mock(PcapMultiCacheable.class);
		when(mockAnnotation.value()).thenReturn("testCache");
		when(mockAnnotation.keys()).thenReturn(new int[]
		{
				0
		});
		when(mockAnnotation.keyPrefix()).thenReturn("prefix");
		when(mockAnnotation.redisType()).thenReturn(RedisType.GEN);
		when(mockAnnotation.keyProvider()).thenAnswer(invocation -> DummyCacheKeyProvider.class);

		mockedCacheAdviceHelper
				.when(() -> CacheAdviceHelper.getMethod(any(ProceedingJoinPoint.class)))
				.thenReturn(DummyClass.class.getMethod("dummyMethod"));
	}

	@Test
	void testCacheMissAndDataMismatchMetric() throws Throwable
	{
		when(redissonClient.getBucket(anyString())
				.get()).thenReturn(null);
		when(mockProceedingJoinPoint().proceed())
				.thenReturn(Collections.singletonList("dbFetchedValue"));

		executeAndVerifyMetrics("miss", "data_mismatch");
	}

	@Test
	void testCacheHitMetric() throws Throwable
	{
		when(redissonClient.getBucket(anyString())
				.get()).thenReturn("cachedValue");

		executeAndVerifyMetrics("hit");
	}

	@Test
	void testCacheFailureAndDataMismatchMetric() throws Throwable
	{
		mockedCacheAdviceHelper
				.when(() -> CacheAdviceHelper.getMethod(any(ProceedingJoinPoint.class)))
				.thenReturn(DummyClass.class.getMethod("failingDummyMethod"));

		when(mockProceedingJoinPoint().proceed()).thenThrow(new RuntimeException("Forced Failure"));
		executeAndVerifyMetrics("failure", "data_mismatch");
	}

	@Test
	void testCacheMissAndCacheDataStoreMetric() throws Throwable
	{
		ProceedingJoinPoint pjp = mockProceedingJoinPoint();
		try (MockedStatic<Metrics> mockedMetrics = mockStatic(Metrics.class))
		{
			Counter mockCounter = mock(Counter.class);
			mockedMetrics.when(() -> Metrics.counter(anyString(), any(String[].class)))
					.thenReturn(mockCounter);

			when(redissonClient.getBucket(anyString())
					.get()).thenReturn(null);

			List<String> expectedDbValues = List.of("dbFetchedValue");
			when(pjp.proceed(any())).thenReturn(expectedDbValues);

			RBucket<Object> mockBucket = mock(RBucket.class);
			when(redissonClient.getBucket(anyString())).thenReturn(mockBucket);
			doNothing().when(mockBucket)
					.set(any(), anyLong(), any());

			Object result = cacheAdvice.doMultiCacheable(pjp, mockAnnotation);
			ArgumentCaptor<String> outcomeCaptor = ArgumentCaptor.forClass(String.class);

			assertNotNull(result);
			assertEquals(expectedDbValues, result);

			mockedMetrics.verify(() -> Metrics.counter(eq("pcap.cache.event"), eq("class"),
					eq("PcapMultiCacheableAdvice"), eq("method"), eq("dummyMethod"), eq("outcome"),
					outcomeCaptor.capture()), atLeastOnce());

			List<String> capturedMetrics = outcomeCaptor.getAllValues();
			logger.info("Captured Metrics: {}", capturedMetrics);

			assertTrue(capturedMetrics.contains("store"));
			assertTrue(capturedMetrics.contains("miss"));
			verify(mockCounter, atLeastOnce()).increment();
		}
	}

	@Test
	void testDataEvictionMetric() throws Throwable
	{
		ProceedingJoinPoint pjp = mockProceedingJoinPoint();
		try (MockedStatic<Metrics> mockedMetrics = mockStatic(Metrics.class))
		{
			Counter mockCounter = mock(Counter.class);
			mockedMetrics.when(() -> Metrics.counter(anyString(), any(String[].class)))
					.thenReturn(mockCounter);

			when(pjp.proceed()).thenThrow(new RuntimeException("Forced Failure"));

			RedissonClient mockRedisson = mock(RedissonClient.class);
			when(cacheAdvice.getRedisson(RedisType.GEN)).thenReturn(mockRedisson);

			RKeys mockKeys = mock(RKeys.class);
			when(mockRedisson.getKeys()).thenReturn(mockKeys);

			doThrow(new RuntimeException("Eviction Failed")).when(mockKeys)
					.delete(any(String[].class));

			Object result;
			try
			{
				result = cacheAdvice.doMultiCacheable(pjp, mockAnnotation);
			}
			catch (Exception ignored)
			{
				result = Collections.emptyList();
			}
			ArgumentCaptor<String> outcomeCaptor = ArgumentCaptor.forClass(String.class);

			assertNotNull(result);

			mockedMetrics.verify(() -> Metrics.counter(eq("pcap.cache.event"), eq("class"),
					eq("PcapMultiCacheableAdvice"), eq("method"), eq("dummyMethod"), eq("outcome"),
					outcomeCaptor.capture()), atLeastOnce());

			List<String> capturedMetrics = outcomeCaptor.getAllValues();
			logger.info("Captured Metrics: {}", capturedMetrics);

			assertTrue(capturedMetrics.contains("failure"));
			assertTrue(capturedMetrics.contains("eviction_failure"));
			verify(mockCounter, atLeastOnce()).increment();
		}
	}

	private void executeAndVerifyMetrics(String... expectedMetrics) throws Throwable
	{
		ProceedingJoinPoint pjp = mockProceedingJoinPoint();
		try (MockedStatic<Metrics> mockedMetrics = mockStatic(Metrics.class))
		{
			Counter mockCounter = mock(Counter.class);
			mockedMetrics.when(() -> Metrics.counter(anyString(), any(String[].class)))
					.thenReturn(mockCounter);

			Object result = cacheAdvice.doMultiCacheable(pjp, mockAnnotation);
			ArgumentCaptor<String> outcomeCaptor = ArgumentCaptor.forClass(String.class);

			assertNotNull(result);
			mockedMetrics.verify(() -> Metrics.counter(eq("pcap.cache.event"), eq("class"),
					eq("PcapMultiCacheableAdvice"), eq("method"), eq("dummyMethod"), eq("outcome"),
					outcomeCaptor.capture()), atLeastOnce());

			List<String> capturedMetrics = outcomeCaptor.getAllValues();
			logger.info("Captured Metrics: {}", capturedMetrics);

			for (String expectedMetric : expectedMetrics)
			{
				assertTrue(capturedMetrics.contains(expectedMetric));
			}
			verify(mockCounter, atLeastOnce()).increment();
		}
	}

	private ProceedingJoinPoint mockProceedingJoinPoint() throws Throwable
	{
		ProceedingJoinPoint pjp = mock(ProceedingJoinPoint.class);
		Signature mockSignature = mock(Signature.class);
		when(pjp.getTarget()).thenReturn(cacheAdvice);
		when(pjp.getSignature()).thenReturn(mockSignature);
		when(mockSignature.getName()).thenReturn("dummyMethod");
		when(pjp.getArgs()).thenReturn(new Object[]
		{
				Collections.singletonList("key1")
		});
		when(pjp.proceed()).thenReturn(Collections.singletonList("dbFetchedValue"));
		return pjp;
	}

	public static class DummyClass
	{
		public static Collection<String> dummyMethod()
		{
			return Collections.emptyList();
		}

		public void failingDummyMethod()
		{
			throw new RuntimeException("Forced Failure");
		}
	}

	public static class DummyCacheKeyProvider implements CacheKeyProvider
	{
		@Override
		public Object getKeyField(Object value)
		{
			return value != null ? value.toString() : "null";
		}
	}

	@AfterAll
	static void releaseMockedStatic()
	{
		if (mockedCacheAdviceHelper != null)
		{
			mockedCacheAdviceHelper.close();
			mockedCacheAdviceHelper = null;
		}
	}

	@AfterEach
	void cleanRedis()
	{
		if (redissonClient != null)
		{
			redissonClient.shutdown();
		}
	}
}

code B:

package com.personalcapital.cache.aop;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.TimeUnit;

import org.apache.commons.lang3.ObjectUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.exception.ExceptionUtils;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.aop.AopInvocationException;
import org.springframework.beans.PropertyAccessorFactory;
import org.springframework.context.EmbeddedValueResolverAware;
import org.springframework.core.annotation.Order;
import org.springframework.util.StringValueResolver;

import com.personalcapital.cache.annotation.PcapCacheable;
import com.personalcapital.cache.annotation.RedisType;
import com.personalcapital.cache.aop.support.AnnotationOrderConstants;
import com.personalcapital.cache.aop.support.CacheAdviceHelper;
import com.personalcapital.cache.aop.support.CacheKeyProvider;
import com.personalcapital.cache.utils.CacheUtils;
import com.personalcapital.log.PcapLogger;
import com.personalcapital.log.PcapLoggerFactory;
import com.safepage.util.Utils;
import io.micrometer.core.instrument.Metrics;

@Aspect
@Order(AnnotationOrderConstants.CACHE_MULTI_CACHING_PRECEDENCE)
public class PcapCacheableAdvice extends CacheAdviceCommons implements EmbeddedValueResolverAware
{
	private static final PcapLogger logger = PcapLoggerFactory
			.getPcapLogger(PcapCacheableAdvice.class);

	private StringValueResolver stringValueResolver;

	private static final String METRIC_NAME = "pcap.cache.event";

	void publishCacheMetrics(ProceedingJoinPoint pjp, String outcome)
	{
		boolean isMetricsEnabled = Boolean
				.parseBoolean(System.getProperty("cache.metrics.enabled", "true"));
		if (!isMetricsEnabled)
		{
			logger.info("Cache metrics are disabled, skipping metrics publication");
			return;
		}
		String className = getClassName(pjp);
		String methodName = getMethodName(pjp);

		Metrics.counter(METRIC_NAME, "class", className, "method", methodName, "outcome", outcome)
				.increment();
		logger.info("Publishing cache metrics - Class: {}, Method: {}, Outcome: {}", className,
				methodName, outcome);
	}

	private String getClassName(ProceedingJoinPoint pjp)
	{
		return pjp.getTarget()
				.getClass()
				.getSimpleName();
	}

	private String getMethodName(ProceedingJoinPoint pjp)
	{
		return pjp.getSignature()
				.getName();
	}

	@Around("@annotation(pcapCacheable)")
	public Object doPcapCacheable(ProceedingJoinPoint pjp, PcapCacheable pcapCacheable)
			throws Throwable
	{
		Method method = null;
		Object[] args = pjp.getArgs();
		Class<?> returnType = null;

		Collection<Object> keyArgs = null;

		String resultKeyField = pcapCacheable.resultKeyField();
		String[] resultKeyFields = pcapCacheable.resultKeyFields();

		boolean cachedValueNullable = pcapCacheable.nullable();
		String keyPrefix = pcapCacheable.keyPrefix();
		CacheKeyProvider cacheKeyProvider = null;
		// get type of cache: default or redis or simple from annotation
		String cacheName = pcapCacheable.value();
		RedisType redisType = pcapCacheable.redisType();
		String key = "";
		if (StringUtils.isBlank(cacheName))
		{
			throw new AopInvocationException(
					"PcapCacheable needs to have cacheName specified in value element.");
		}

		try
		{
			cacheKeyProvider = pcapCacheable.keyProvider()
					.getDeclaredConstructor()
					.newInstance();
			method = CacheAdviceHelper.getMethod(pjp);
			returnType = method.getReturnType();

			// check expected return type
			if (returnType.equals(Void.TYPE))
			{
				throw new AopInvocationException(
						"PcapCacheable cannot apply to method without return.");
			}

			// check if keyIndices are provided for keyName generation
			int[] keyIndice = pcapCacheable.keys();

			// get Arguments to generate key
			if (args == null || args.length == 0)
			{
				key = CacheUtils.generateKey(cacheName, keyPrefix, null);
			}
			else
			{
				keyArgs = new ArrayList<Object>();
				if (keyIndice == null || keyIndice.length == 0)
				{
					for (int i = 0; i < args.length; i++)
					{
						Object arg = args[i];
						keyArgs.add(cacheKeyProvider.getKeyField(arg));
					}
				}
				else
				{
					// if we provide a list of indices for the args that have to be used for keys,
					// use
					// this to generate keys
					for (int keyIndex : keyIndice)
					{
						if (keyIndex >= args.length)
							continue;

						Object arg = args[keyIndex];

						keyArgs.add(cacheKeyProvider.getKeyField(arg));
					}
				}

				// get key generated from all values gathered so far
				key = CacheUtils.generateKey(cacheName, keyPrefix, keyArgs);
			}
			// get cachedValue
			Object cachedValue = getRedisson(redisType).getBucket(key)
					.get();
			if (!(cachedValue == null
					|| (cachedValue instanceof ObjectUtils.Null && cachedValueNullable == false)))
			{
				publishCacheMetrics(pjp, "hit");
				return CacheUtils.getValue(cachedValue);
			}
		}
		catch (Exception ex)
		{
			logger.info("Caching on {} aborted due to an error. message: {}. stacktrace: {}",
					pjp.toShortString(), ex.getMessage(), ExceptionUtils.getStackTrace(ex));
			publishCacheMetrics(pjp, "failure");
			// PLAT-849 evictFrom redis on exception and proceeds to populate in subsequent call
			if (!evictFromRedis(redisType, key))
			{
				// if eviction fails we fetch from db and return
				return pjp.proceed();
			}
		}

		final Object resultItemForMissed = pjp.proceed(args);
		publishCacheMetrics(pjp, "miss");

		if (resultItemForMissed == null && cachedValueNullable == false)
		{
			return resultItemForMissed;
		}

		int ttl = pcapCacheable.ttlSeconds();
		final String ttlExpression = pcapCacheable.ttlExpression();

		int ttlSeconds = resolveTtl(ttlExpression, cacheName, ttl);

		try
		{
			// check if something from the result has to be used as part of the key.
			if (Utils.isNotNull(resultKeyField)
					|| (resultKeyFields != null && resultKeyFields.length > 0))
			{
				// cannot cache null value if result is used for key provider
				if (resultItemForMissed == null)
				{
					return resultItemForMissed;
				}

				List<Object> keyFieldValues = new ArrayList<Object>();

				if ((resultKeyFields != null && resultKeyFields.length > 0))
				{
					// if key is to be derived from result, then get the field from result
					// using reflection and create the cache key
					for (int i = 0; i < resultKeyFields.length; i++)
					{
						Object keyFieldValue = PropertyAccessorFactory
								.forBeanPropertyAccess(resultItemForMissed)
								.getPropertyValue(resultKeyFields[i]);
						keyFieldValues.add(cacheKeyProvider.getKeyField(keyFieldValue));
					}
				}
				else
				{// is only one is property is given use that value for key directly
					Object keyFieldValue = PropertyAccessorFactory
							.forBeanPropertyAccess(resultItemForMissed)
							.getPropertyValue(resultKeyField);

					if (keyFieldValue != null)
					{
						keyFieldValues.add(cacheKeyProvider.getKeyField(keyFieldValue));
					}
				}

				// genearteKey and add the item fetched from db.
				if (keyFieldValues.size() > 0)
				{
					String cacheKey = CacheUtils.generateKey(cacheName, keyPrefix, keyFieldValues,
							keyArgs);
					getRedisson(redisType).getBucket(cacheKey)
							.set(resultItemForMissed, ttlSeconds, TimeUnit.SECONDS);
				}
			}
			else
			{
				String cacheKey = CacheUtils.generateKey(cacheName, keyPrefix, keyArgs);
				getRedisson(redisType).getBucket(cacheKey)
						.set(resultItemForMissed == null ? ObjectUtils.NULL : resultItemForMissed,
								ttlSeconds, TimeUnit.SECONDS);
			}
		}
		catch (Exception ex)
		{
			logger.info("Caching on {} aborted due to an error. message: {}. stacktrace: {}",
					pjp.toShortString(), ex.getMessage(), ExceptionUtils.getStackTrace(ex));
			publishCacheMetrics(pjp, "failure");
		}

		return resultItemForMissed;
	}

	private int resolveTtl(String ttlExpression, String cacheName, int ttl)
	{
		Integer fromProperty = null;
		if (StringUtils.isNotBlank(ttlExpression))
		{
			try
			{
				String stringValue = stringValueResolver.resolveStringValue(ttlExpression);
				if (stringValue != null)
				{
					fromProperty = Integer.parseInt(stringValue);
				}
			}
			catch (Exception e)
			{
				logger.error("Exception resolving ttl {} for cache name {}", ttlExpression,
						cacheName);
			}
		}
		return fromProperty == null ? getTtlFromConfiguration(cacheName, ttl) : fromProperty;
	}

	@Override
	public void setEmbeddedValueResolver(StringValueResolver stringValueResolver)
	{
		this.stringValueResolver = stringValueResolver;
	}
}
