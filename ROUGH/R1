package com.personalcapital.cache.aop;

import java.util.Arrays;
import java.util.List;

import com.personalcapital.log.PcapLogger;
import com.personalcapital.log.PcapLoggerFactory;
import io.micrometer.core.instrument.Metrics;
import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.Signature;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.MockedStatic;

import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

public class PcapMultiCacheableAdviceTest
{
	private static final PcapLogger logger = PcapLoggerFactory.getPcapLogger(
			PcapMultiCacheableAdviceTest.class);
	private PcapMultiCacheableAdvice cacheAdvice;
	private SimpleMeterRegistry meterRegistry;

	@BeforeEach
	void setUp()
	{
		meterRegistry = new SimpleMeterRegistry();
		Metrics.addRegistry(meterRegistry);
		cacheAdvice = new PcapMultiCacheableAdvice();
	}

	@Test
	void testRecordCachingMetric()
	{
		ProceedingJoinPoint pjp = mock(ProceedingJoinPoint.class);
		Signature mockSignature = mock(Signature.class);

		PcapMultiCacheableAdvice advice = new PcapMultiCacheableAdvice();
		when(pjp.getTarget()).thenReturn(advice);
		when(pjp.getSignature()).thenReturn(mockSignature);
		when(pjp.getSignature()
				.getName()).thenReturn("testMethod");

		try (MockedStatic<Metrics> mockedMetrics = mockStatic(Metrics.class))
		{
			Counter mockCounter = mock(Counter.class);
			mockedMetrics.when(() -> Metrics.counter(anyString(), any(String[].class)))
					.thenReturn(mockCounter);
			cacheAdvice.publishCacheMetrics(pjp, "miss");

			ArgumentCaptor<String> metricName = ArgumentCaptor.forClass(String.class);
			ArgumentCaptor<String[]> tagsSentToDatadog = ArgumentCaptor.forClass(String[].class);

			mockedMetrics.verify(
					() -> Metrics.counter(metricName.capture(), tagsSentToDatadog.capture()));

			assertEquals("pcap.cache.event", metricName.getValue());
			verify(mockCounter, times(1)).increment();

			logger.info("Metric Captured : {} " + metricName.getValue());
			logger.info("Captured Tags: {}" + Arrays.toString(tagsSentToDatadog.getValue()));
		}
	}

	@Test
	void testPulbishCacheMetrics_onEvictionFailure() throws Throwable{
		ProceedingJoinPoint pjp = mock(ProceedingJoinPoint.class);
		Signature mockSignature = mock(Signature.class);

		PcapMultiCacheableAdvice advice = spy(new PcapMultiCacheableAdvice());
		when(pjp.getTarget()).thenReturn(advice);
		when(pjp.getSignature()).thenReturn(mockSignature);
		when(pjp.getSignature()
				.getName()).thenReturn("testMethod");
		when(pjp.getArgs()).thenReturn(new Object[]{"testKey"});

		doThrow(new RuntimeException("Cache eviction failed")).when(advice).evictFromRedis(any(),anyList());

		try (MockedStatic<Metrics> mockedMetrics = mockStatic(Metrics.class))
		{
			Counter mockCounter = mock(Counter.class);
			mockedMetrics.when(() -> Metrics.counter(anyString(), any(String[].class)))
					.thenReturn(mockCounter);

			try{
				advice.doMultiCacheable(pjp, null);
			}catch (Exception e){

			}
			ArgumentCaptor<String> metricName = ArgumentCaptor.forClass(String.class);
			ArgumentCaptor<String[]> tagsSentToDatadog = ArgumentCaptor.forClass(String[].class);

			mockedMetrics.verify(
					() -> Metrics.counter(metricName.capture(), tagsSentToDatadog.capture()));

			assertEquals("pcap.cache.event", metricName.getValue());
			assertTrue(Arrays.asList(tagsSentToDatadog.getValue()).contains("eviction_failure"));
			verify(mockCounter, times(1)).increment();

			logger.info("Metric Captured : {} " + metricName.getValue());
			logger.info("Captured Tags: {}" + Arrays.toString(tagsSentToDatadog.getValue()));
		}
	}
}

the first test case is passing as expected , but the second one is failing with this error: 

Wanted but not invoked:
Metrics.class.counter(
    <Capturing argument: String>,
    <Capturing argument: String[]>
);
-> at io.micrometer.core.instrument.Metrics.counter(Metrics.java:76)
Actually, there were zero interactions with this mock.

Wanted but not invoked:
Metrics.class.counter(
    <Capturing argument: String>,
    <Capturing argument: String[]>
);
-> at io.micrometer.core.instrument.Metrics.counter(Metrics.java:76)
Actually, there were zero interactions with this mock.

	at io.micrometer.core.instrument.Metrics.counter(Metrics.java:76)
	at com.personalcapital.cache.aop.PcapMultiCacheableAdviceTest.lambda$testPulbishCacheMetrics_onEvictionFailure$3(PcapMultiCacheableAdviceTest.java:98)
	at com.personalcapital.cache.aop.PcapMultiCacheableAdviceTest.testPulbishCacheMetrics_onEvictionFailure(PcapMultiCacheableAdviceTest.java:97)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1596)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1596)


Process finished with exit code 255

can you help me
