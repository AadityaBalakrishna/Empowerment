package com.personalcapital.cache.aop;

import com.personalcapital.cache.annotation.PcapMultiCacheable;
import com.personalcapital.cache.annotation.RedisType;
import com.personalcapital.cache.aop.support.CacheKeyProvider;
import com.personalcapital.cache.aop.support.DefaultCacheKeyProvider;
import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.Metrics;
import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.Signature;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import org.redisson.api.RBucket;
import org.redisson.api.RedissonClient;
import org.redisson.spring.cache.CacheConfig;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest(classes = {PcapMultiCacheableAdvice.class, PcapMultiCacheableAdviceMetricsTest.TestConfig.class})
public class PcapMultiCacheableAdviceMetricsTest {

	@Autowired
	private PcapMultiCacheableAdvice cacheAdvice;

	private SimpleMeterRegistry meterRegistry;

	@MockBean
	@Qualifier("redisson")
	private RedissonClient redissonGen;

	@MockBean
	@Qualifier("redissonHa")
	private RedissonClient redissonHa;

	@MockBean
	private RBucket<Object> mockBucket;

	private PcapMultiCacheable mockAnnotation;

	@BeforeEach
	void setUp()
	{
		meterRegistry = new SimpleMeterRegistry();
		Metrics.addRegistry(meterRegistry);
		cacheAdvice = new PcapMultiCacheableAdvice();

		mockBucket = mock(RBucket.class);
		when(redissonGen.getBucket(anyString())).thenReturn(mockBucket);
		when(redissonHa.getBucket(anyString())).thenReturn(mockBucket);

		mockAnnotation = mock(PcapMultiCacheable.class);
		when(mockAnnotation.value()).thenReturn("testCache");
		when(mockAnnotation.keys()).thenReturn(new int[] { 0 });
		when(mockAnnotation.keyPrefix()).thenReturn("prefix");
		when(mockAnnotation.redisType()).thenReturn(RedisType.DEFAULT);

		when(mockAnnotation.keyProvider()).thenAnswer(invocation -> DummyCacheKeyProvider.class);
	}

//	private void injectPrivateField(Object target, String fieldName, Object value)
//	{
//		try{
//			java.lang.reflect.Field field = target.getClass()
//					.getDeclaredField(fieldName);
//			field.setAccessible(true);
//			field.set(target, value);
//		}catch (Exception e){
//			throw new RuntimeException("Failed to inject Private field " + fieldName, e);
//		}
//	}

	@Test
	void testCacheHitMetricThroughDoMultiCacheable() throws Throwable {
		ProceedingJoinPoint pjp = mockProceedingJoinPoint();
		when(mockBucket.get()).thenReturn("cachedValue"); // Simulate cache hit

		try (MockedStatic<Metrics> mockedMetrics = Mockito.mockStatic(Metrics.class)) {
			Counter mockCounter = mock(Counter.class);
			mockedMetrics.when(() -> Metrics.counter(anyString(), any(String[].class))).thenReturn(mockCounter);

			Object result = cacheAdvice.doMultiCacheable(pjp, mockAnnotation);

			System.out.println("Checking if RedissonClient is injected: " + redissonGen);
			System.out.println("Checking if getBucket() is working: " + redissonGen.getBucket("prefix_key1"));
			System.out.println("Checking if bucket.get() is returning: " + mockBucket.get());
			System.out.println("Executing doMultiCacheable..." + mockAnnotation);
			System.out.println("Executing doMultiCacheable...");

//			System.out.println("Checking cache for key: " + computedCacheKey);
//			Object cachedValue = redissonGen.getBucket(computedCacheKey).get();
//			System.out.println("Cached value retrieved: " + cachedValue);

			assertNotNull(result);
			assertEquals("cachedValue", result);

			mockedMetrics.verify(() -> Metrics.counter("pcap.cache.event", "class", "PcapMultiCacheableAdvice",
					"method", "testMethod", "outcome", "hit"), times(1));

			verify(mockCounter, times(1)).increment();
		}
	}

	private ProceedingJoinPoint mockProceedingJoinPoint() {
		ProceedingJoinPoint pjp = mock(ProceedingJoinPoint.class);
		Signature mockSignature = mock(Signature.class);
		when(pjp.getTarget()).thenReturn(cacheAdvice);
		when(pjp.getSignature()).thenReturn(mockSignature);
		when(mockSignature.getName()).thenReturn("testMethod");
		when(pjp.getArgs()).thenReturn(new Object[]{Collections.singletonList("key1")});
		return pjp;
	}

	public static class DummyCacheKeyProvider implements CacheKeyProvider{
		@Override
		public Object getKeyField(Object value){
			return value != null ? value.toString() : "null";
		}
	}

	@Configuration
	static class TestConfig{
		@Bean
		@Primary
		@Qualifier("redisson")
		public RedissonClient redissonGen(){
			return mock(RedissonClient.class);
		}

		@Bean
		@Primary
		@Qualifier("redissonHa")
		public RedissonClient redissonHa(){
			return mock(RedissonClient.class);
		}

		@Bean
		public Map<String, CacheConfig> redisCacheExpires(){
			Map<String, CacheConfig> cacheConfigMap = new HashMap<>();
			cacheConfigMap.put("testCache",new CacheConfig(1000, 2000));
			return cacheConfigMap;
		}
	}
}

java.lang.NullPointerException: Cannot invoke "java.util.Map.get(Object)" because "this.redisCacheExpires" is null
