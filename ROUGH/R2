Please verify if the test - WorkflowChainBuilderTest follow this - Java Testing Guidelines Addendum , if not make the necessary changes please


3. Code Coverage Requirement  - Ensure unit tests achieve at least 80% coverage or higher.  [Mine is class - 100%, method - 80%, Line - 83%, branch - 83%]

5. Test Naming Standards 
Use @DisplayName annotations in Givenâ€“Whenâ€“Then format.s 

Example: 
Given missing details, When validation runs, Then validation should fail. 
@DisplayName("Given missing details, When validation runs, Then validation should fail") 

5. Meaningful Assertion Messages 
Assertions must include clear, descriptive messages. 

Example: 
Expected validation to fail for missing detail. 
assertEquals(false, result, ">Comment: Expected validation to fail for missing detail>"); 

6. Mock External Dependencies Properly 
Use Mockito for external calls, repositories, or services. Avoid hitting real external systems. 

7. Follow the AAA Pattern (Arrange-Act-Assert) 
Each test should follow Arrange, Act, Assert for clarity. 

AAA Pattern Example 

Scenario: 
We want to test a Validator class that checks whether an input string is not empty. 
Code Under Test 
public class Validator { 
    public boolean isValid(String input) { 
        return input != null && !input.trim().isEmpty(); 
    } 
} 

Shape 

âœ… JUnit Test Using AAA Pattern 

class ValidatorTest { 
    @Test 
    @DisplayName("Given empty string, When validation runs, Then validation should fail") 
    void shouldFailValidationWhenInputIsEmpty() { 
        // Arrange 
        Validator validator = new Validator(); 
        String input = ""; 

        // Act 
        boolean result = validator.isValid(input); 

        // Assert 
        assertFalse(result, ">Comment: Expected validation to fail for empty input>"); 
    } 
} 

Shape 

ðŸ” Breakdown of AAA Pattern 

1. Arrange 
Prepare your objects, inputs, mocks, or test data. 
Validator validator = new Validator(); 
String input = ""; 

2. Act 
Execute the method being tested. 
boolean result = validator.isValid(input); 

3. Assert 
Verify the outcome. 
assertFalse(result, ">Comment: Expected validation to fail for empty input>"); 

8. Validate Negative and Edge Cases 
Include null inputs, empty collections, boundary values, and invalid scenarios. 

9. Use Test Data Builders 
Improves reusability and reduces clutter in test setup. 

10. Keep Unit Tests Independent 
Each test should run in isolation with no shared mutable state. 

11. Clean Up Resources 
Use @AfterEach / @AfterAll to close resources or mocks when needed. 

12. Use Meaningful Test Method Names 
Example: shouldFailValidationWhenDetailsAreMissing() 


test - 
package com.empower.crm.core.engine.chain;

import com.empower.crm.core.engine.factory.WorkflowStepProcessorFactory;
import com.empower.crm.core.engine.processor.WorkflowStepProcessor;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.test.util.ReflectionTestUtils;

import java.util.*;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

/**
 * Unit tests for WorkflowChainBuilder.
 */
@ExtendWith(MockitoExtension.class)
class WorkflowChainBuilderTest
{

	@Mock
	private WorkflowStepProcessorFactory processorFactory;

	@Mock
	private WorkflowStepProcessor workflowStepProcessor;

	private WorkflowChainBuilder workflowChainBuilder;

	@BeforeEach
	void setUp()
	{
		workflowChainBuilder = new WorkflowChainBuilder(processorFactory);
	}

	/**
	 * Test Points covered: 1. Test buildChain() retrieves beans from context with correct bean
	 * names 2. Test buildChain() creates chain with handlers in correct phase order 3. Test
	 * buildChain() links handler.setNext() correctly
	 */
	@Test
	void testBuildChain_ConstructsCorrectChain()
	{
		String stepType = "validation";

		// Create 3 distinct configurations to verify order
		Map<String, Object> config1 = Map.of("stepId", "1", "action", "verify_email");
		Map<String, Object> config2 = Map.of("stepId", "2", "action", "verify_phone");
		Map<String, Object> config3 = Map.of("stepId", "3", "action", "verify_address");

		List<Map<String, Object>> stepConfigs = Arrays.asList(config1, config2, config3);

		// Mock the factory to return a processor when asked for "validation"
		when(processorFactory.getProcessor(stepType)).thenReturn(workflowStepProcessor);

		WorkflowStepHandler firstHandler = workflowChainBuilder.buildChain(stepType, stepConfigs);

		// Verify factory was called with the correct name (Bean Retrieval)
		verify(processorFactory, times(1)).getProcessor(stepType);

		// Verify First Handler exists and has correct config
		assertNotNull(firstHandler, "The first handler in the chain should not be null");
		Map<String, Object> actualConfig1 = (Map<String, Object>) ReflectionTestUtils
				.getField(firstHandler, "stepConfig");
		assertEquals(config1, actualConfig1,
				"First handler should contain the first configuration map");

		// Verify Linkage to Second Handler
		WorkflowStepHandler secondHandler = (WorkflowStepHandler) ReflectionTestUtils
				.getField(firstHandler, "nextHandler");
		assertNotNull(secondHandler, "First handler should be linked to a second handler");
		Map<String, Object> actualConfig2 = (Map<String, Object>) ReflectionTestUtils
				.getField(secondHandler, "stepConfig");
		assertEquals(config2, actualConfig2,
				"Second handler should contain the second configuration map");

		// Verify Linkage to Third Handler
		WorkflowStepHandler thirdHandler = (WorkflowStepHandler) ReflectionTestUtils
				.getField(secondHandler, "nextHandler");
		assertNotNull(thirdHandler, "The second handler should link to the third handler");
		Map<String, Object> actualConfig3 = (Map<String, Object>) ReflectionTestUtils
				.getField(thirdHandler, "stepConfig");
		assertEquals(config3, actualConfig3,
				"The third handler should have the correct configuration");

		// Verify End of Chain
		WorkflowStepHandler fourthHandler = (WorkflowStepHandler) ReflectionTestUtils
				.getField(thirdHandler, "nextHandler");
		assertNull(fourthHandler, "The third handler should not link to any further handlers");
	}

	/**
	 * Test Point: Test buildChain() handles empty phase configurations appropriately
	 */
	@Test
	void testBuildChain_WithEmptyConfig()
	{
		String stepType = "transform";
		List<Map<String, Object>> emptyConfigs = Collections.emptyList();

		WorkflowStepHandler result = workflowChainBuilder.buildChain(stepType, emptyConfigs);

		assertNull(result, "The result should be null when the configuration list is empty");
		verifyNoInteractions(processorFactory);
	}

	/**
	 * Test Point: Test buildChain() handles null phase configurations appropriately
	 */
	@Test
	void testBuildChain_WithNullConfig()
	{
		String stepType = "transform";

		WorkflowStepHandler result = workflowChainBuilder.buildChain(stepType, null);

		assertNull(result, "The result should be null when the configuration list is null");
		verifyNoInteractions(processorFactory);
	}

	/**
	 * Test Point: Test buildChain() throws Exception for missing/invalid bean names. Note: Testing
	 * for IllegalArgumentException as defined in the provided Factory class.
	 */
	@Test
	void testBuildChain_ThrowsException_WhenBeanNotFound()
	{
		String invalidStepType = "unknown_process";
		List<Map<String, Object>> stepConfigs = Collections.singletonList(Map.of("key", "val"));

		// Simulate Factory throwing exception when bean name is unknown
		when(processorFactory.getProcessor(invalidStepType)).thenThrow(new IllegalArgumentException(
				"No processor found for step type: " + invalidStepType));

		IllegalArgumentException exception = assertThrows(IllegalArgumentException.class,
				() -> workflowChainBuilder.buildChain(invalidStepType, stepConfigs));

		assertEquals("No processor found for step type: unknown_process", exception.getMessage(),
				"The exception message should indicate the missing processor for the invalid step type");
		verify(processorFactory).getProcessor(invalidStepType);
	}

	/**
	 * TEST POINT: Boundary Condition Test buildChain() with exactly one step to ensure loop handles
	 * single-item lists without attempting to link a non-existent second handler.
	 */
	@Test
	void testBuildChain_SingleStep()
	{
		String stepType = "email";
		Map<String, Object> expectedConfig = Map.of("id", "single");
		List<Map<String, Object>> stepConfigs = Collections.singletonList(expectedConfig);

		when(processorFactory.getProcessor(stepType)).thenReturn(workflowStepProcessor);

		WorkflowStepHandler result = workflowChainBuilder.buildChain(stepType, stepConfigs);

		assertNotNull(result, "The result should not be null for a single-step configuration");

		// Verify the handler has the correct configuration
		Map<String, Object> actualConfig = (Map<String, Object>) ReflectionTestUtils
				.getField(result, "stepConfig");
		assertNotNull(actualConfig, "The handler's configuration should not be null");
		assertEquals(expectedConfig, actualConfig,
				"The handler should have the correct configuration");

		// Verify nextHandler is null
		Object nextHandler = ReflectionTestUtils.getField(result, "nextHandler");
		assertNull(nextHandler, "Single step handler should not have a next handler");
	}

	/**
	 * TEST POINT: Robustness Test buildChain() when the input list contains a null element.
	 */
	@Test
	void testBuildChain_ListWithNulls()
	{
		String stepType = "validation";
		// List with one valid config and one null config
		List<Map<String, Object>> stepConfigs = Arrays.asList(Map.of("id", "1"), null);

		when(processorFactory.getProcessor(stepType)).thenReturn(workflowStepProcessor);

		WorkflowStepHandler firstHandler = workflowChainBuilder.buildChain(stepType, stepConfigs);

		assertNotNull(firstHandler,
				"The first handler should not be null even if the list contains null");

		// Verify second handler was created even with null config
		WorkflowStepHandler secondHandler = (WorkflowStepHandler) ReflectionTestUtils
				.getField(firstHandler, "nextHandler");
		assertNotNull(secondHandler,
				"The second handler should be created even for a null configuration");

		Map<String, Object> secondConfig = (Map<String, Object>) ReflectionTestUtils
				.getField(secondHandler, "stepConfig");
		assertNull(secondConfig, "The second handler should have a null configuration");
	}

	/**
	 * Test Point: Test buildChain() handles null step type appropriately by throwing an exception
	 */
	@Test
	void testBuildChain_NullStepType()
	{
		String stepType = null;
		List<Map<String, Object>> stepConfigs = Collections.singletonList(Map.of("id", "1"));

		when(processorFactory.getProcessor(stepType)).thenThrow(
				new IllegalArgumentException("No processor found for step type: " + stepType));
		IllegalArgumentException exception = assertThrows(IllegalArgumentException.class,
				() -> workflowChainBuilder.buildChain(stepType, stepConfigs));
		assertEquals("No processor found for step type: null", exception.getMessage(),
				"The exception message should indicate the missing processor for the null step type");
	}

	/**
	 * Test Point: Test buildChain() handles single configuration with null values appropriately
	 */
	@Test
	void testBuildChain_SingleConfigWithNullValues()
	{
		String stepType = "validation";
		Map<String, Object> configWithNullValues = new HashMap<>();
		configWithNullValues.put("key", null); // Allows null values
		List<Map<String, Object>> stepConfigs = Collections.singletonList(configWithNullValues);

		when(processorFactory.getProcessor(stepType)).thenReturn(workflowStepProcessor);

		WorkflowStepHandler result = workflowChainBuilder.buildChain(stepType, stepConfigs);

		assertNotNull(result,
				"The handler should not be null even if the config contains null values");
		Map<String, Object> actualConfig = (Map<String, Object>) ReflectionTestUtils
				.getField(result, "stepConfig");
		assertEquals(configWithNullValues, actualConfig,
				"The handler should retain the null values in the config");
	}

	/**
	 * Test Point: Test buildChain() creates separate chains for different step types without
	 * interference.
	 */
	@Test
	void testBuildChain_MultipleChainsWithDifferentStepTypes()
	{
		String stepType1 = "validation";
		String stepType2 = "transformation";

		List<Map<String, Object>> stepConfigs1 = Collections.singletonList(Map.of("id", "1"));
		List<Map<String, Object>> stepConfigs2 = Collections.singletonList(Map.of("id", "2"));

		when(processorFactory.getProcessor(stepType1)).thenReturn(workflowStepProcessor);
		when(processorFactory.getProcessor(stepType2)).thenReturn(workflowStepProcessor);

		WorkflowStepHandler chain1 = workflowChainBuilder.buildChain(stepType1, stepConfigs1);
		WorkflowStepHandler chain2 = workflowChainBuilder.buildChain(stepType2, stepConfigs2);

		assertNotNull(chain1, "The first chain should not be null");
		assertNotNull(chain2, "The second chain should not be null");

		Map<String, Object> config1 = (Map<String, Object>) ReflectionTestUtils.getField(chain1,
				"stepConfig");
		Map<String, Object> config2 = (Map<String, Object>) ReflectionTestUtils.getField(chain2,
				"stepConfig");

		assertEquals(stepConfigs1.get(0), config1,
				"The first chain should have the correct configuration");
		assertEquals(stepConfigs2.get(0), config2,
				"The second chain should have the correct configuration");
	}
}
