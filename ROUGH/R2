package com.empower.epw.crm.gateway.sqs;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;

import com.empower.epw.sqs.EmpowerSQSService;
import com.personalcapital.log.PcapLogger;
import com.personalcapital.log.PcapLoggerFactory;

import static org.assertj.core.api.Assertions.assertThat;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.retry.annotation.Backoff;
import org.springframework.retry.annotation.EnableRetry;
import org.springframework.retry.annotation.Retryable;

@SpringBootTest
@EnableAutoConfiguration
@ActiveProfiles("test")
@EnableRetry
public class CrmGatewaySqsIntegrationTest extends CrmGatewaySqsContainerIT {

    private static final PcapLogger logger = PcapLoggerFactory.getPcapLogger(CrmGatewaySqsIntegrationTest.class);

    @Autowired
    private EmpowerSQSService empowerSQSService;

    @Autowired
    private TestListener listener;

    @Test
    void shouldSendAndReceiveMessageOnAllQueues() {
        for (String queueName : QUEUE_NAMES) {
            String expectedMessage = "Hello from CRM Gateway - " + queueName;

            empowerSQSService.sendMessage(queueName, expectedMessage);
            String actualMessage = empowerSQSService.reciveMessage(queueName, String.class);

            assertThat(actualMessage)
                    .as("Verify message for queue: " + queueName)
                    .isEqualTo(expectedMessage);

            logger.info("Message verified for queue: {}" + queueName);
        }
    }

    @Test
    void shouldRetryOnFailureForAllQueues() {
        for (String queueName : QUEUE_NAMES) {
            String failMessage = "SIMULATE_FAIL_" + queueName;
            empowerSQSService.sendMessage(queueName, failMessage);

            // Add a small delay to ensure the message is available in the queue
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }

            String result = listener.processMessageWithRetry(queueName, failMessage);

            assertThat(result)
                    .as("Retry verified for queue: " + queueName)
                    .isEqualTo(failMessage);

            logger.info("Retry verified for queue: {}", queueName);
        }
    }

    @Configuration
    static class TestListenerConfig {
        @Bean
        TestListener testListener(EmpowerSQSService service) {
            return new TestListener(service);
        }
    }

    static class TestListener {
        private final EmpowerSQSService empowerSQSService;
        private int attempt = 0;

        TestListener(EmpowerSQSService empowerSQSService) {
            this.empowerSQSService = empowerSQSService;
        }

        @Retryable(
                value = { RuntimeException.class },
                maxAttemptsExpression = "#{3}",
                backoff = @Backoff(delayExpression = "#{500}")
        )
        public String processMessageWithRetry(String queueName, String expectedFailMessage) {
            String msg = empowerSQSService.reciveMessage(queueName, String.class, 10);
            if (msg == null) {
                throw new RuntimeException("No message received");
            }

            // Fail first 2 attempts, succeed on 3rd
            attempt++;
            if (expectedFailMessage.equals(msg) && attempt < 3) {
                logger.info("Simulated failure attempt {} for queue {}", attempt, queueName);
                throw new RuntimeException("Simulated failure");
            }

            logger.info("Message processed successfully on attempt {} for queue {}", attempt, queueName);
            return msg;
        }
    }
}

i am told that these is an issue with the sendmessage part , so is there any other solution for this test ? else we can just avoid the send message part
